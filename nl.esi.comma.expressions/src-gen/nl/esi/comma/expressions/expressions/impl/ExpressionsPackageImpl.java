/**
 * generated by Xtext 2.25.0
 */
package nl.esi.comma.expressions.expressions.impl;

import nl.esi.comma.expressions.expressions.Expression;
import nl.esi.comma.expressions.expressions.ExpressionAddition;
import nl.esi.comma.expressions.expressions.ExpressionAnd;
import nl.esi.comma.expressions.expressions.ExpressionAny;
import nl.esi.comma.expressions.expressions.ExpressionBinary;
import nl.esi.comma.expressions.expressions.ExpressionBracket;
import nl.esi.comma.expressions.expressions.ExpressionConstantBool;
import nl.esi.comma.expressions.expressions.ExpressionConstantInt;
import nl.esi.comma.expressions.expressions.ExpressionConstantString;
import nl.esi.comma.expressions.expressions.ExpressionDivision;
import nl.esi.comma.expressions.expressions.ExpressionEnumLiteral;
import nl.esi.comma.expressions.expressions.ExpressionEqual;
import nl.esi.comma.expressions.expressions.ExpressionFunctionCall;
import nl.esi.comma.expressions.expressions.ExpressionGeq;
import nl.esi.comma.expressions.expressions.ExpressionGreater;
import nl.esi.comma.expressions.expressions.ExpressionLeq;
import nl.esi.comma.expressions.expressions.ExpressionLess;
import nl.esi.comma.expressions.expressions.ExpressionMap;
import nl.esi.comma.expressions.expressions.ExpressionMaximum;
import nl.esi.comma.expressions.expressions.ExpressionMinimum;
import nl.esi.comma.expressions.expressions.ExpressionMinus;
import nl.esi.comma.expressions.expressions.ExpressionModulo;
import nl.esi.comma.expressions.expressions.ExpressionMultiply;
import nl.esi.comma.expressions.expressions.ExpressionNEqual;
import nl.esi.comma.expressions.expressions.ExpressionNot;
import nl.esi.comma.expressions.expressions.ExpressionOr;
import nl.esi.comma.expressions.expressions.ExpressionPlus;
import nl.esi.comma.expressions.expressions.ExpressionPower;
import nl.esi.comma.expressions.expressions.ExpressionQuantifier;
import nl.esi.comma.expressions.expressions.ExpressionSubtraction;
import nl.esi.comma.expressions.expressions.ExpressionUnary;
import nl.esi.comma.expressions.expressions.ExpressionVariable;
import nl.esi.comma.expressions.expressions.ExpressionVector;
import nl.esi.comma.expressions.expressions.ExpressionsFactory;
import nl.esi.comma.expressions.expressions.ExpressionsPackage;
import nl.esi.comma.expressions.expressions.Pair;
import nl.esi.comma.expressions.expressions.TypeAnnotation;
import nl.esi.comma.expressions.expressions.Variable;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;

import org.eclipse.emf.ecore.impl.EPackageImpl;

/**
 * <!-- begin-user-doc -->
 * An implementation of the model <b>Package</b>.
 * <!-- end-user-doc -->
 * @generated
 */
public class ExpressionsPackageImpl extends EPackageImpl implements ExpressionsPackage
{
  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass variableEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionNotEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionMinusEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionPlusEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionBracketEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionConstantBoolEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionConstantIntEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionConstantStringEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionEnumLiteralEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionVariableEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionAnyEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionFunctionCallEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionQuantifierEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass typeAnnotationEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass pairEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionBinaryEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionUnaryEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionAndEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionOrEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionEqualEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionNEqualEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionGeqEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionGreaterEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionLeqEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionLessEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionAdditionEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionSubtractionEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionMultiplyEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionDivisionEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionMaximumEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionMinimumEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionModuloEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionPowerEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionVectorEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EClass expressionMapEClass = null;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private EEnum quantifierEEnum = null;

  /**
   * Creates an instance of the model <b>Package</b>, registered with
   * {@link org.eclipse.emf.ecore.EPackage.Registry EPackage.Registry} by the package
   * package URI value.
   * <p>Note: the correct way to create the package is via the static
   * factory method {@link #init init()}, which also performs
   * initialization of the package, or returns the registered package,
   * if one already exists.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see org.eclipse.emf.ecore.EPackage.Registry
   * @see nl.esi.comma.expressions.expressions.ExpressionsPackage#eNS_URI
   * @see #init()
   * @generated
   */
  private ExpressionsPackageImpl()
  {
    super(eNS_URI, ExpressionsFactory.eINSTANCE);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private static boolean isInited = false;

  /**
   * Creates, registers, and initializes the <b>Package</b> for this model, and for any others upon which it depends.
   *
   * <p>This method is used to initialize {@link ExpressionsPackage#eINSTANCE} when that field is accessed.
   * Clients should not invoke it directly. Instead, they should simply access that field to obtain the package.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #eNS_URI
   * @see #createPackageContents()
   * @see #initializePackageContents()
   * @generated
   */
  public static ExpressionsPackage init()
  {
    if (isInited) return (ExpressionsPackage)EPackage.Registry.INSTANCE.getEPackage(ExpressionsPackage.eNS_URI);

    // Obtain or create and register package
    Object registeredExpressionsPackage = EPackage.Registry.INSTANCE.get(eNS_URI);
    ExpressionsPackageImpl theExpressionsPackage = registeredExpressionsPackage instanceof ExpressionsPackageImpl ? (ExpressionsPackageImpl)registeredExpressionsPackage : new ExpressionsPackageImpl();

    isInited = true;

    // Create package meta-data objects
    theExpressionsPackage.createPackageContents();

    // Initialize created meta-data
    theExpressionsPackage.initializePackageContents();

    // Mark meta-data to indicate it can't be changed
    theExpressionsPackage.freeze();

    // Update the registry and return the package
    EPackage.Registry.INSTANCE.put(ExpressionsPackage.eNS_URI, theExpressionsPackage);
    return theExpressionsPackage;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getVariable()
  {
    return variableEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EAttribute getVariable_Name()
  {
    return (EAttribute)variableEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpression()
  {
    return expressionEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionNot()
  {
    return expressionNotEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionMinus()
  {
    return expressionMinusEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionPlus()
  {
    return expressionPlusEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionBracket()
  {
    return expressionBracketEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionConstantBool()
  {
    return expressionConstantBoolEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EAttribute getExpressionConstantBool_Value()
  {
    return (EAttribute)expressionConstantBoolEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionConstantInt()
  {
    return expressionConstantIntEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EAttribute getExpressionConstantInt_Value()
  {
    return (EAttribute)expressionConstantIntEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionConstantString()
  {
    return expressionConstantStringEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EAttribute getExpressionConstantString_Value()
  {
    return (EAttribute)expressionConstantStringEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionEnumLiteral()
  {
    return expressionEnumLiteralEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EAttribute getExpressionEnumLiteral_Type()
  {
    return (EAttribute)expressionEnumLiteralEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EAttribute getExpressionEnumLiteral_Literal()
  {
    return (EAttribute)expressionEnumLiteralEClass.getEStructuralFeatures().get(1);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionVariable()
  {
    return expressionVariableEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EAttribute getExpressionVariable_Name()
  {
    return (EAttribute)expressionVariableEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionAny()
  {
    return expressionAnyEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionFunctionCall()
  {
    return expressionFunctionCallEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EAttribute getExpressionFunctionCall_FunctionName()
  {
    return (EAttribute)expressionFunctionCallEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EReference getExpressionFunctionCall_Args()
  {
    return (EReference)expressionFunctionCallEClass.getEStructuralFeatures().get(1);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionQuantifier()
  {
    return expressionQuantifierEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EAttribute getExpressionQuantifier_Quantifier()
  {
    return (EAttribute)expressionQuantifierEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EReference getExpressionQuantifier_Iterator()
  {
    return (EReference)expressionQuantifierEClass.getEStructuralFeatures().get(1);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EReference getExpressionQuantifier_Collection()
  {
    return (EReference)expressionQuantifierEClass.getEStructuralFeatures().get(2);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EReference getExpressionQuantifier_Condition()
  {
    return (EReference)expressionQuantifierEClass.getEStructuralFeatures().get(3);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getTypeAnnotation()
  {
    return typeAnnotationEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EAttribute getTypeAnnotation_Type()
  {
    return (EAttribute)typeAnnotationEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getPair()
  {
    return pairEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EReference getPair_Key()
  {
    return (EReference)pairEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EReference getPair_Value()
  {
    return (EReference)pairEClass.getEStructuralFeatures().get(1);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionBinary()
  {
    return expressionBinaryEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EReference getExpressionBinary_Left()
  {
    return (EReference)expressionBinaryEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EReference getExpressionBinary_Right()
  {
    return (EReference)expressionBinaryEClass.getEStructuralFeatures().get(1);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionUnary()
  {
    return expressionUnaryEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EReference getExpressionUnary_Sub()
  {
    return (EReference)expressionUnaryEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionAnd()
  {
    return expressionAndEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionOr()
  {
    return expressionOrEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionEqual()
  {
    return expressionEqualEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionNEqual()
  {
    return expressionNEqualEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionGeq()
  {
    return expressionGeqEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionGreater()
  {
    return expressionGreaterEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionLeq()
  {
    return expressionLeqEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionLess()
  {
    return expressionLessEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionAddition()
  {
    return expressionAdditionEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionSubtraction()
  {
    return expressionSubtractionEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionMultiply()
  {
    return expressionMultiplyEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionDivision()
  {
    return expressionDivisionEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionMaximum()
  {
    return expressionMaximumEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionMinimum()
  {
    return expressionMinimumEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionModulo()
  {
    return expressionModuloEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionPower()
  {
    return expressionPowerEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionVector()
  {
    return expressionVectorEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EReference getExpressionVector_TypeAnnotation()
  {
    return (EReference)expressionVectorEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EReference getExpressionVector_Elements()
  {
    return (EReference)expressionVectorEClass.getEStructuralFeatures().get(1);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EClass getExpressionMap()
  {
    return expressionMapEClass;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EReference getExpressionMap_TypeAnnotation()
  {
    return (EReference)expressionMapEClass.getEStructuralFeatures().get(0);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EReference getExpressionMap_Pairs()
  {
    return (EReference)expressionMapEClass.getEStructuralFeatures().get(1);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public EEnum getQUANTIFIER()
  {
    return quantifierEEnum;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public ExpressionsFactory getExpressionsFactory()
  {
    return (ExpressionsFactory)getEFactoryInstance();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private boolean isCreated = false;

  /**
   * Creates the meta-model objects for the package.  This method is
   * guarded to have no affect on any invocation but its first.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public void createPackageContents()
  {
    if (isCreated) return;
    isCreated = true;

    // Create classes and their features
    variableEClass = createEClass(VARIABLE);
    createEAttribute(variableEClass, VARIABLE__NAME);

    expressionEClass = createEClass(EXPRESSION);

    expressionNotEClass = createEClass(EXPRESSION_NOT);

    expressionMinusEClass = createEClass(EXPRESSION_MINUS);

    expressionPlusEClass = createEClass(EXPRESSION_PLUS);

    expressionBracketEClass = createEClass(EXPRESSION_BRACKET);

    expressionConstantBoolEClass = createEClass(EXPRESSION_CONSTANT_BOOL);
    createEAttribute(expressionConstantBoolEClass, EXPRESSION_CONSTANT_BOOL__VALUE);

    expressionConstantIntEClass = createEClass(EXPRESSION_CONSTANT_INT);
    createEAttribute(expressionConstantIntEClass, EXPRESSION_CONSTANT_INT__VALUE);

    expressionConstantStringEClass = createEClass(EXPRESSION_CONSTANT_STRING);
    createEAttribute(expressionConstantStringEClass, EXPRESSION_CONSTANT_STRING__VALUE);

    expressionEnumLiteralEClass = createEClass(EXPRESSION_ENUM_LITERAL);
    createEAttribute(expressionEnumLiteralEClass, EXPRESSION_ENUM_LITERAL__TYPE);
    createEAttribute(expressionEnumLiteralEClass, EXPRESSION_ENUM_LITERAL__LITERAL);

    expressionVariableEClass = createEClass(EXPRESSION_VARIABLE);
    createEAttribute(expressionVariableEClass, EXPRESSION_VARIABLE__NAME);

    expressionAnyEClass = createEClass(EXPRESSION_ANY);

    expressionFunctionCallEClass = createEClass(EXPRESSION_FUNCTION_CALL);
    createEAttribute(expressionFunctionCallEClass, EXPRESSION_FUNCTION_CALL__FUNCTION_NAME);
    createEReference(expressionFunctionCallEClass, EXPRESSION_FUNCTION_CALL__ARGS);

    expressionQuantifierEClass = createEClass(EXPRESSION_QUANTIFIER);
    createEAttribute(expressionQuantifierEClass, EXPRESSION_QUANTIFIER__QUANTIFIER);
    createEReference(expressionQuantifierEClass, EXPRESSION_QUANTIFIER__ITERATOR);
    createEReference(expressionQuantifierEClass, EXPRESSION_QUANTIFIER__COLLECTION);
    createEReference(expressionQuantifierEClass, EXPRESSION_QUANTIFIER__CONDITION);

    typeAnnotationEClass = createEClass(TYPE_ANNOTATION);
    createEAttribute(typeAnnotationEClass, TYPE_ANNOTATION__TYPE);

    pairEClass = createEClass(PAIR);
    createEReference(pairEClass, PAIR__KEY);
    createEReference(pairEClass, PAIR__VALUE);

    expressionBinaryEClass = createEClass(EXPRESSION_BINARY);
    createEReference(expressionBinaryEClass, EXPRESSION_BINARY__LEFT);
    createEReference(expressionBinaryEClass, EXPRESSION_BINARY__RIGHT);

    expressionUnaryEClass = createEClass(EXPRESSION_UNARY);
    createEReference(expressionUnaryEClass, EXPRESSION_UNARY__SUB);

    expressionAndEClass = createEClass(EXPRESSION_AND);

    expressionOrEClass = createEClass(EXPRESSION_OR);

    expressionEqualEClass = createEClass(EXPRESSION_EQUAL);

    expressionNEqualEClass = createEClass(EXPRESSION_NEQUAL);

    expressionGeqEClass = createEClass(EXPRESSION_GEQ);

    expressionGreaterEClass = createEClass(EXPRESSION_GREATER);

    expressionLeqEClass = createEClass(EXPRESSION_LEQ);

    expressionLessEClass = createEClass(EXPRESSION_LESS);

    expressionAdditionEClass = createEClass(EXPRESSION_ADDITION);

    expressionSubtractionEClass = createEClass(EXPRESSION_SUBTRACTION);

    expressionMultiplyEClass = createEClass(EXPRESSION_MULTIPLY);

    expressionDivisionEClass = createEClass(EXPRESSION_DIVISION);

    expressionMaximumEClass = createEClass(EXPRESSION_MAXIMUM);

    expressionMinimumEClass = createEClass(EXPRESSION_MINIMUM);

    expressionModuloEClass = createEClass(EXPRESSION_MODULO);

    expressionPowerEClass = createEClass(EXPRESSION_POWER);

    expressionVectorEClass = createEClass(EXPRESSION_VECTOR);
    createEReference(expressionVectorEClass, EXPRESSION_VECTOR__TYPE_ANNOTATION);
    createEReference(expressionVectorEClass, EXPRESSION_VECTOR__ELEMENTS);

    expressionMapEClass = createEClass(EXPRESSION_MAP);
    createEReference(expressionMapEClass, EXPRESSION_MAP__TYPE_ANNOTATION);
    createEReference(expressionMapEClass, EXPRESSION_MAP__PAIRS);

    // Create enums
    quantifierEEnum = createEEnum(QUANTIFIER);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  private boolean isInitialized = false;

  /**
   * Complete the initialization of the package and its meta-model.  This
   * method is guarded to have no affect on any invocation but its first.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public void initializePackageContents()
  {
    if (isInitialized) return;
    isInitialized = true;

    // Initialize package
    setName(eNAME);
    setNsPrefix(eNS_PREFIX);
    setNsURI(eNS_URI);

    // Create type parameters

    // Set bounds for type parameters

    // Add supertypes to classes
    expressionNotEClass.getESuperTypes().add(this.getExpression());
    expressionNotEClass.getESuperTypes().add(this.getExpressionUnary());
    expressionMinusEClass.getESuperTypes().add(this.getExpression());
    expressionMinusEClass.getESuperTypes().add(this.getExpressionUnary());
    expressionPlusEClass.getESuperTypes().add(this.getExpression());
    expressionPlusEClass.getESuperTypes().add(this.getExpressionUnary());
    expressionBracketEClass.getESuperTypes().add(this.getExpression());
    expressionBracketEClass.getESuperTypes().add(this.getExpressionUnary());
    expressionConstantBoolEClass.getESuperTypes().add(this.getExpression());
    expressionConstantIntEClass.getESuperTypes().add(this.getExpression());
    expressionConstantStringEClass.getESuperTypes().add(this.getExpression());
    expressionVariableEClass.getESuperTypes().add(this.getExpression());
    expressionQuantifierEClass.getESuperTypes().add(this.getExpression());
    typeAnnotationEClass.getESuperTypes().add(this.getExpression());
    expressionBinaryEClass.getESuperTypes().add(this.getExpression());
    expressionUnaryEClass.getESuperTypes().add(this.getExpression());
    expressionAndEClass.getESuperTypes().add(this.getExpression());
    expressionAndEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionOrEClass.getESuperTypes().add(this.getExpression());
    expressionOrEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionEqualEClass.getESuperTypes().add(this.getExpression());
    expressionEqualEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionNEqualEClass.getESuperTypes().add(this.getExpression());
    expressionNEqualEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionGeqEClass.getESuperTypes().add(this.getExpression());
    expressionGeqEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionGreaterEClass.getESuperTypes().add(this.getExpression());
    expressionGreaterEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionLeqEClass.getESuperTypes().add(this.getExpression());
    expressionLeqEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionLessEClass.getESuperTypes().add(this.getExpression());
    expressionLessEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionAdditionEClass.getESuperTypes().add(this.getExpression());
    expressionAdditionEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionSubtractionEClass.getESuperTypes().add(this.getExpression());
    expressionSubtractionEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionMultiplyEClass.getESuperTypes().add(this.getExpression());
    expressionMultiplyEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionDivisionEClass.getESuperTypes().add(this.getExpression());
    expressionDivisionEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionMaximumEClass.getESuperTypes().add(this.getExpression());
    expressionMaximumEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionMinimumEClass.getESuperTypes().add(this.getExpression());
    expressionMinimumEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionModuloEClass.getESuperTypes().add(this.getExpression());
    expressionModuloEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionPowerEClass.getESuperTypes().add(this.getExpression());
    expressionPowerEClass.getESuperTypes().add(this.getExpressionBinary());
    expressionVectorEClass.getESuperTypes().add(this.getExpression());
    expressionMapEClass.getESuperTypes().add(this.getExpression());

    // Initialize classes and features; add operations and parameters
    initEClass(variableEClass, Variable.class, "Variable", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEAttribute(getVariable_Name(), ecorePackage.getEString(), "name", null, 0, 1, Variable.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(expressionEClass, Expression.class, "Expression", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionNotEClass, ExpressionNot.class, "ExpressionNot", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionMinusEClass, ExpressionMinus.class, "ExpressionMinus", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionPlusEClass, ExpressionPlus.class, "ExpressionPlus", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionBracketEClass, ExpressionBracket.class, "ExpressionBracket", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionConstantBoolEClass, ExpressionConstantBool.class, "ExpressionConstantBool", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEAttribute(getExpressionConstantBool_Value(), ecorePackage.getEBoolean(), "value", null, 0, 1, ExpressionConstantBool.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(expressionConstantIntEClass, ExpressionConstantInt.class, "ExpressionConstantInt", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEAttribute(getExpressionConstantInt_Value(), ecorePackage.getEInt(), "value", null, 0, 1, ExpressionConstantInt.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(expressionConstantStringEClass, ExpressionConstantString.class, "ExpressionConstantString", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEAttribute(getExpressionConstantString_Value(), ecorePackage.getEString(), "value", null, 0, 1, ExpressionConstantString.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(expressionEnumLiteralEClass, ExpressionEnumLiteral.class, "ExpressionEnumLiteral", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEAttribute(getExpressionEnumLiteral_Type(), ecorePackage.getEString(), "type", null, 0, 1, ExpressionEnumLiteral.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEAttribute(getExpressionEnumLiteral_Literal(), ecorePackage.getEString(), "literal", null, 0, 1, ExpressionEnumLiteral.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(expressionVariableEClass, ExpressionVariable.class, "ExpressionVariable", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEAttribute(getExpressionVariable_Name(), ecorePackage.getEString(), "name", null, 0, 1, ExpressionVariable.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(expressionAnyEClass, ExpressionAny.class, "ExpressionAny", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionFunctionCallEClass, ExpressionFunctionCall.class, "ExpressionFunctionCall", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEAttribute(getExpressionFunctionCall_FunctionName(), ecorePackage.getEString(), "functionName", null, 0, 1, ExpressionFunctionCall.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEReference(getExpressionFunctionCall_Args(), this.getExpression(), null, "args", null, 0, -1, ExpressionFunctionCall.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(expressionQuantifierEClass, ExpressionQuantifier.class, "ExpressionQuantifier", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEAttribute(getExpressionQuantifier_Quantifier(), this.getQUANTIFIER(), "quantifier", null, 0, 1, ExpressionQuantifier.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEReference(getExpressionQuantifier_Iterator(), this.getVariable(), null, "iterator", null, 0, 1, ExpressionQuantifier.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEReference(getExpressionQuantifier_Collection(), this.getExpression(), null, "collection", null, 0, 1, ExpressionQuantifier.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEReference(getExpressionQuantifier_Condition(), this.getExpression(), null, "condition", null, 0, 1, ExpressionQuantifier.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(typeAnnotationEClass, TypeAnnotation.class, "TypeAnnotation", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEAttribute(getTypeAnnotation_Type(), ecorePackage.getEString(), "type", null, 0, 1, TypeAnnotation.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(pairEClass, Pair.class, "Pair", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEReference(getPair_Key(), this.getExpression(), null, "key", null, 0, 1, Pair.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEReference(getPair_Value(), this.getExpression(), null, "value", null, 0, 1, Pair.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(expressionBinaryEClass, ExpressionBinary.class, "ExpressionBinary", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEReference(getExpressionBinary_Left(), this.getExpression(), null, "left", null, 0, 1, ExpressionBinary.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEReference(getExpressionBinary_Right(), this.getExpression(), null, "right", null, 0, 1, ExpressionBinary.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(expressionUnaryEClass, ExpressionUnary.class, "ExpressionUnary", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEReference(getExpressionUnary_Sub(), this.getExpression(), null, "sub", null, 0, 1, ExpressionUnary.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(expressionAndEClass, ExpressionAnd.class, "ExpressionAnd", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionOrEClass, ExpressionOr.class, "ExpressionOr", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionEqualEClass, ExpressionEqual.class, "ExpressionEqual", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionNEqualEClass, ExpressionNEqual.class, "ExpressionNEqual", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionGeqEClass, ExpressionGeq.class, "ExpressionGeq", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionGreaterEClass, ExpressionGreater.class, "ExpressionGreater", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionLeqEClass, ExpressionLeq.class, "ExpressionLeq", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionLessEClass, ExpressionLess.class, "ExpressionLess", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionAdditionEClass, ExpressionAddition.class, "ExpressionAddition", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionSubtractionEClass, ExpressionSubtraction.class, "ExpressionSubtraction", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionMultiplyEClass, ExpressionMultiply.class, "ExpressionMultiply", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionDivisionEClass, ExpressionDivision.class, "ExpressionDivision", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionMaximumEClass, ExpressionMaximum.class, "ExpressionMaximum", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionMinimumEClass, ExpressionMinimum.class, "ExpressionMinimum", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionModuloEClass, ExpressionModulo.class, "ExpressionModulo", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionPowerEClass, ExpressionPower.class, "ExpressionPower", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);

    initEClass(expressionVectorEClass, ExpressionVector.class, "ExpressionVector", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEReference(getExpressionVector_TypeAnnotation(), this.getTypeAnnotation(), null, "typeAnnotation", null, 0, 1, ExpressionVector.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEReference(getExpressionVector_Elements(), this.getExpression(), null, "elements", null, 0, -1, ExpressionVector.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    initEClass(expressionMapEClass, ExpressionMap.class, "ExpressionMap", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEReference(getExpressionMap_TypeAnnotation(), this.getTypeAnnotation(), null, "typeAnnotation", null, 0, 1, ExpressionMap.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEReference(getExpressionMap_Pairs(), this.getPair(), null, "pairs", null, 0, -1, ExpressionMap.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    // Initialize enums and add enum literals
    initEEnum(quantifierEEnum, nl.esi.comma.expressions.expressions.QUANTIFIER.class, "QUANTIFIER");
    addEEnumLiteral(quantifierEEnum, nl.esi.comma.expressions.expressions.QUANTIFIER.EXISTS);
    addEEnumLiteral(quantifierEEnum, nl.esi.comma.expressions.expressions.QUANTIFIER.FORALL);
    addEEnumLiteral(quantifierEEnum, nl.esi.comma.expressions.expressions.QUANTIFIER.DELETE);

    // Create resource
    createResource(eNS_URI);
  }

} //ExpressionsPackageImpl
