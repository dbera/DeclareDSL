/*
 * generated by Xtext 2.25.0
 */
package nl.esi.comma.behavior.scl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import nl.esi.comma.expressions.services.ExpressionsGrammarAccess;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class SclGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFeaturesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFeaturesFeaturesParserRuleCall_0_0 = (RuleCall)cFeaturesAssignment_0.eContents().get(0);
		private final Assignment cActionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cActionsActionsParserRuleCall_1_0 = (RuleCall)cActionsAssignment_1.eContents().get(0);
		private final Assignment cSequencesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSequencesSequenceDefParserRuleCall_2_0 = (RuleCall)cSequencesAssignment_2.eContents().get(0);
		private final Keyword cRequirementsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cCompositionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCompositionCompositionParserRuleCall_4_0 = (RuleCall)cCompositionAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cForConfigurationsKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cCommonFeaturesAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final CrossReference cCommonFeaturesFeatureCrossReference_5_1_0 = (CrossReference)cCommonFeaturesAssignment_5_1.eContents().get(0);
		private final RuleCall cCommonFeaturesFeatureIDTerminalRuleCall_5_1_0_1 = (RuleCall)cCommonFeaturesFeatureCrossReference_5_1_0.eContents().get(1);
		private final Assignment cTemplatesAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cTemplatesTemplatesParserRuleCall_6_0 = (RuleCall)cTemplatesAssignment_6.eContents().get(0);
		private final Assignment cUseLabelsAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final Keyword cUseLabelsUseProvidedLabelsKeyword_7_0 = (Keyword)cUseLabelsAssignment_7.eContents().get(0);
		
		//Model:
		//    features += Features*
		//    actions += Actions+
		//    sequences += SequenceDef*
		//    'Requirements'
		//    composition += Composition*
		//    ('for-configurations' commonFeatures += [Feature|ID]+)?
		//    templates += Templates*
		//    useLabels?= 'use-provided-labels'?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//features += Features*
		//actions += Actions+
		//sequences += SequenceDef*
		//'Requirements'
		//composition += Composition*
		//('for-configurations' commonFeatures += [Feature|ID]+)?
		//templates += Templates*
		//useLabels?= 'use-provided-labels'?
		public Group getGroup() { return cGroup; }
		
		//features += Features*
		public Assignment getFeaturesAssignment_0() { return cFeaturesAssignment_0; }
		
		//Features
		public RuleCall getFeaturesFeaturesParserRuleCall_0_0() { return cFeaturesFeaturesParserRuleCall_0_0; }
		
		//actions += Actions+
		public Assignment getActionsAssignment_1() { return cActionsAssignment_1; }
		
		//Actions
		public RuleCall getActionsActionsParserRuleCall_1_0() { return cActionsActionsParserRuleCall_1_0; }
		
		//sequences += SequenceDef*
		public Assignment getSequencesAssignment_2() { return cSequencesAssignment_2; }
		
		//SequenceDef
		public RuleCall getSequencesSequenceDefParserRuleCall_2_0() { return cSequencesSequenceDefParserRuleCall_2_0; }
		
		//'Requirements'
		public Keyword getRequirementsKeyword_3() { return cRequirementsKeyword_3; }
		
		//composition += Composition*
		public Assignment getCompositionAssignment_4() { return cCompositionAssignment_4; }
		
		//Composition
		public RuleCall getCompositionCompositionParserRuleCall_4_0() { return cCompositionCompositionParserRuleCall_4_0; }
		
		//('for-configurations' commonFeatures += [Feature|ID]+)?
		public Group getGroup_5() { return cGroup_5; }
		
		//'for-configurations'
		public Keyword getForConfigurationsKeyword_5_0() { return cForConfigurationsKeyword_5_0; }
		
		//commonFeatures += [Feature|ID]+
		public Assignment getCommonFeaturesAssignment_5_1() { return cCommonFeaturesAssignment_5_1; }
		
		//[Feature|ID]
		public CrossReference getCommonFeaturesFeatureCrossReference_5_1_0() { return cCommonFeaturesFeatureCrossReference_5_1_0; }
		
		//ID
		public RuleCall getCommonFeaturesFeatureIDTerminalRuleCall_5_1_0_1() { return cCommonFeaturesFeatureIDTerminalRuleCall_5_1_0_1; }
		
		//templates += Templates*
		public Assignment getTemplatesAssignment_6() { return cTemplatesAssignment_6; }
		
		//Templates
		public RuleCall getTemplatesTemplatesParserRuleCall_6_0() { return cTemplatesTemplatesParserRuleCall_6_0; }
		
		//useLabels?= 'use-provided-labels'?
		public Assignment getUseLabelsAssignment_7() { return cUseLabelsAssignment_7; }
		
		//'use-provided-labels'
		public Keyword getUseLabelsUseProvidedLabelsKeyword_7_0() { return cUseLabelsUseProvidedLabelsKeyword_7_0; }
	}
	public class CompositionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Composition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstraintKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cIsComposedOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTemplatesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cTemplatesTemplatesCrossReference_4_0 = (CrossReference)cTemplatesAssignment_4.eContents().get(0);
		private final RuleCall cTemplatesTemplatesIDTerminalRuleCall_4_0_1 = (RuleCall)cTemplatesTemplatesCrossReference_4_0.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cDescriptionKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cDescTxtAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cDescTxtSTRINGTerminalRuleCall_6_1_0 = (RuleCall)cDescTxtAssignment_6_1.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cForConfigurationsKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cCommonFeaturesAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final CrossReference cCommonFeaturesFeatureCrossReference_7_1_0 = (CrossReference)cCommonFeaturesAssignment_7_1.eContents().get(0);
		private final RuleCall cCommonFeaturesFeatureIDTerminalRuleCall_7_1_0_1 = (RuleCall)cCommonFeaturesFeatureCrossReference_7_1_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_7_2 = (Keyword)cGroup_7.eContents().get(2);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cRequirementTagsKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cTagStrAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cTagStrSTRINGTerminalRuleCall_8_1_0 = (RuleCall)cTagStrAssignment_8_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_8_2 = (Keyword)cGroup_8.eContents().get(2);
		
		//Composition:
		//    'constraint' name = ID 'is-composed-of' '{' templates += [Templates|ID]+ '}'
		//    ('description' descTxt = STRING)?
		//    ('for-configurations' commonFeatures += [Feature|ID]+ ';')?
		//    ('requirement-tags' tagStr += STRING* ';')?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'constraint' name = ID 'is-composed-of' '{' templates += [Templates|ID]+ '}'
		//('description' descTxt = STRING)?
		//('for-configurations' commonFeatures += [Feature|ID]+ ';')?
		//('requirement-tags' tagStr += STRING* ';')?
		public Group getGroup() { return cGroup; }
		
		//'constraint'
		public Keyword getConstraintKeyword_0() { return cConstraintKeyword_0; }
		
		//name = ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'is-composed-of'
		public Keyword getIsComposedOfKeyword_2() { return cIsComposedOfKeyword_2; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//templates += [Templates|ID]+
		public Assignment getTemplatesAssignment_4() { return cTemplatesAssignment_4; }
		
		//[Templates|ID]
		public CrossReference getTemplatesTemplatesCrossReference_4_0() { return cTemplatesTemplatesCrossReference_4_0; }
		
		//ID
		public RuleCall getTemplatesTemplatesIDTerminalRuleCall_4_0_1() { return cTemplatesTemplatesIDTerminalRuleCall_4_0_1; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
		
		//('description' descTxt = STRING)?
		public Group getGroup_6() { return cGroup_6; }
		
		//'description'
		public Keyword getDescriptionKeyword_6_0() { return cDescriptionKeyword_6_0; }
		
		//descTxt = STRING
		public Assignment getDescTxtAssignment_6_1() { return cDescTxtAssignment_6_1; }
		
		//STRING
		public RuleCall getDescTxtSTRINGTerminalRuleCall_6_1_0() { return cDescTxtSTRINGTerminalRuleCall_6_1_0; }
		
		//('for-configurations' commonFeatures += [Feature|ID]+ ';')?
		public Group getGroup_7() { return cGroup_7; }
		
		//'for-configurations'
		public Keyword getForConfigurationsKeyword_7_0() { return cForConfigurationsKeyword_7_0; }
		
		//commonFeatures += [Feature|ID]+
		public Assignment getCommonFeaturesAssignment_7_1() { return cCommonFeaturesAssignment_7_1; }
		
		//[Feature|ID]
		public CrossReference getCommonFeaturesFeatureCrossReference_7_1_0() { return cCommonFeaturesFeatureCrossReference_7_1_0; }
		
		//ID
		public RuleCall getCommonFeaturesFeatureIDTerminalRuleCall_7_1_0_1() { return cCommonFeaturesFeatureIDTerminalRuleCall_7_1_0_1; }
		
		//';'
		public Keyword getSemicolonKeyword_7_2() { return cSemicolonKeyword_7_2; }
		
		//('requirement-tags' tagStr += STRING* ';')?
		public Group getGroup_8() { return cGroup_8; }
		
		//'requirement-tags'
		public Keyword getRequirementTagsKeyword_8_0() { return cRequirementTagsKeyword_8_0; }
		
		//tagStr += STRING*
		public Assignment getTagStrAssignment_8_1() { return cTagStrAssignment_8_1; }
		
		//STRING
		public RuleCall getTagStrSTRINGTerminalRuleCall_8_1_0() { return cTagStrSTRINGTerminalRuleCall_8_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_8_2() { return cSemicolonKeyword_8_2; }
	}
	public class SequenceDefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.SequenceDef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSequenceDefKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cActListAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cActListParamActParserRuleCall_3_0 = (RuleCall)cActListAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//SequenceDef:
		//    'Sequence-Def' name = ID '{'
		//        actList += ParamAct+
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'Sequence-Def' name = ID '{'
		//    actList += ParamAct+
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'Sequence-Def'
		public Keyword getSequenceDefKeyword_0() { return cSequenceDefKeyword_0; }
		
		//name = ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//actList += ParamAct+
		public Assignment getActListAssignment_3() { return cActListAssignment_3; }
		
		//ParamAct
		public RuleCall getActListParamActParserRuleCall_3_0() { return cActListParamActParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class ParamActElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.ParamAct");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cActAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cActActionCrossReference_0_0 = (CrossReference)cActAssignment_0.eContents().get(0);
		private final RuleCall cActActionIDTerminalRuleCall_0_0_1 = (RuleCall)cActActionCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cIdxAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIdxINTTerminalRuleCall_1_1_0 = (RuleCall)cIdxAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//ParamAct:
		//    act = [Action|ID] ('['idx = INT']')?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//act = [Action|ID] ('['idx = INT']')?
		public Group getGroup() { return cGroup; }
		
		//act = [Action|ID]
		public Assignment getActAssignment_0() { return cActAssignment_0; }
		
		//[Action|ID]
		public CrossReference getActActionCrossReference_0_0() { return cActActionCrossReference_0_0; }
		
		//ID
		public RuleCall getActActionIDTerminalRuleCall_0_0_1() { return cActActionIDTerminalRuleCall_0_0_1; }
		
		//('['idx = INT']')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }
		
		//idx = INT
		public Assignment getIdxAssignment_1_1() { return cIdxAssignment_1_1; }
		
		//INT
		public RuleCall getIdxINTTerminalRuleCall_1_1_0() { return cIdxINTTerminalRuleCall_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}
	public class RefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Ref");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRefSequenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRefStepParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Ref returns Ref:
		//    RefSequence | RefStep
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//RefSequence | RefStep
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//RefSequence
		public RuleCall getRefSequenceParserRuleCall_0() { return cRefSequenceParserRuleCall_0; }
		
		//RefStep
		public RuleCall getRefStepParserRuleCall_1() { return cRefStepParserRuleCall_1; }
	}
	public class RefStepElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.RefStep");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cActKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStepAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cStepActionCrossReference_1_0 = (CrossReference)cStepAssignment_1.eContents().get(0);
		private final RuleCall cStepActionIDTerminalRuleCall_1_0_1 = (RuleCall)cStepActionCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cIdxAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cIdxINTTerminalRuleCall_2_1_0 = (RuleCall)cIdxAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//RefStep:
		//    'act' step = [Action|ID] ('['idx = INT']')?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'act' step = [Action|ID] ('['idx = INT']')?
		public Group getGroup() { return cGroup; }
		
		//'act'
		public Keyword getActKeyword_0() { return cActKeyword_0; }
		
		//step = [Action|ID]
		public Assignment getStepAssignment_1() { return cStepAssignment_1; }
		
		//[Action|ID]
		public CrossReference getStepActionCrossReference_1_0() { return cStepActionCrossReference_1_0; }
		
		//ID
		public RuleCall getStepActionIDTerminalRuleCall_1_0_1() { return cStepActionIDTerminalRuleCall_1_0_1; }
		
		//('['idx = INT']')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_2_0() { return cLeftSquareBracketKeyword_2_0; }
		
		//idx = INT
		public Assignment getIdxAssignment_2_1() { return cIdxAssignment_2_1; }
		
		//INT
		public RuleCall getIdxINTTerminalRuleCall_2_1_0() { return cIdxINTTerminalRuleCall_2_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_2_2() { return cRightSquareBracketKeyword_2_2; }
	}
	public class RefSequenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.RefSequence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSeqKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSeqAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cSeqSequenceDefCrossReference_1_0 = (CrossReference)cSeqAssignment_1.eContents().get(0);
		private final RuleCall cSeqSequenceDefIDTerminalRuleCall_1_0_1 = (RuleCall)cSeqSequenceDefCrossReference_1_0.eContents().get(1);
		
		//RefSequence:
		//    'seq' seq = [SequenceDef|ID]
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'seq' seq = [SequenceDef|ID]
		public Group getGroup() { return cGroup; }
		
		//'seq'
		public Keyword getSeqKeyword_0() { return cSeqKeyword_0; }
		
		//seq = [SequenceDef|ID]
		public Assignment getSeqAssignment_1() { return cSeqAssignment_1; }
		
		//[SequenceDef|ID]
		public CrossReference getSeqSequenceDefCrossReference_1_0() { return cSeqSequenceDefCrossReference_1_0; }
		
		//ID
		public RuleCall getSeqSequenceDefIDTerminalRuleCall_1_0_1() { return cSeqSequenceDefIDTerminalRuleCall_1_0_1; }
	}
	public class FeaturesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Features");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFeatureListKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFeatureAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFeatureFeatureParserRuleCall_2_0 = (RuleCall)cFeatureAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Features:
		//    'feature-list:' '{'
		//        feature += Feature+
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'feature-list:' '{'
		//    feature += Feature+
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'feature-list:'
		public Keyword getFeatureListKeyword_0() { return cFeatureListKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//feature += Feature+
		public Assignment getFeatureAssignment_2() { return cFeatureAssignment_2; }
		
		//Feature
		public RuleCall getFeatureFeatureParserRuleCall_2_0() { return cFeatureFeatureParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class FeatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Feature");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Feature:
		//    name = ID
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name = ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class ActionsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Actions");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cActionListKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cActAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cActActionParserRuleCall_2_0 = (RuleCall)cActAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Actions:
		//    'action-list:' '{'
		//        act += Action+
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'action-list:' '{'
		//    act += Action+
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'action-list:'
		public Keyword getActionListKeyword_0() { return cActionListKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//act += Action+
		public Assignment getActAssignment_2() { return cActAssignment_2; }
		
		//Action
		public RuleCall getActActionParserRuleCall_2_0() { return cActActionParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class ActionParamElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.ActionParam");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWithKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParametersAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParametersExpressionParserRuleCall_2_0 = (RuleCall)cParametersAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cParametersAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cParametersExpressionParserRuleCall_3_1_0 = (RuleCall)cParametersAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ActionParam:
		//    'with' '(' parameters+=Expression (',' parameters+=Expression)* ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'with' '(' parameters+=Expression (',' parameters+=Expression)* ')'
		public Group getGroup() { return cGroup; }
		
		//'with'
		public Keyword getWithKeyword_0() { return cWithKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//parameters+=Expression
		public Assignment getParametersAssignment_2() { return cParametersAssignment_2; }
		
		//Expression
		public RuleCall getParametersExpressionParserRuleCall_2_0() { return cParametersExpressionParserRuleCall_2_0; }
		
		//(',' parameters+=Expression)*
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//parameters+=Expression
		public Assignment getParametersAssignment_3_1() { return cParametersAssignment_3_1; }
		
		//Expression
		public RuleCall getParametersExpressionParserRuleCall_3_1_0() { return cParametersExpressionParserRuleCall_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class ActionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Action");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cActAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cActActionTypeEnumRuleCall_0_0 = (RuleCall)cActAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cLabelAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLabelSTRINGTerminalRuleCall_2_0 = (RuleCall)cLabelAssignment_2.eContents().get(0);
		private final Assignment cActParamAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cActParamActionParamParserRuleCall_3_0 = (RuleCall)cActParamAssignment_3.eContents().get(0);
		
		//// name is used as reference|ID by templates. In generator this must be changed
		//Action:
		//    act = ActionType name = ID label = STRING (actParam += ActionParam+)?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//act = ActionType name = ID label = STRING (actParam += ActionParam+)?
		public Group getGroup() { return cGroup; }
		
		//act = ActionType
		public Assignment getActAssignment_0() { return cActAssignment_0; }
		
		//ActionType
		public RuleCall getActActionTypeEnumRuleCall_0_0() { return cActActionTypeEnumRuleCall_0_0; }
		
		//name = ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//label = STRING
		public Assignment getLabelAssignment_2() { return cLabelAssignment_2; }
		
		//STRING
		public RuleCall getLabelSTRINGTerminalRuleCall_2_0() { return cLabelSTRINGTerminalRuleCall_2_0; }
		
		//(actParam += ActionParam+)?
		public Assignment getActParamAssignment_3() { return cActParamAssignment_3; }
		
		//ActionParam
		public RuleCall getActParamActionParamParserRuleCall_3_0() { return cActParamActionParamParserRuleCall_3_0; }
	}
	public class TemplatesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Templates");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cTypeAlternatives_1_0 = (Alternatives)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cTypeDependenciesParserRuleCall_1_0_0 = (RuleCall)cTypeAlternatives_1_0.eContents().get(0);
		private final RuleCall cTypePastParserRuleCall_1_0_1 = (RuleCall)cTypeAlternatives_1_0.eContents().get(1);
		private final RuleCall cTypeFutureParserRuleCall_1_0_2 = (RuleCall)cTypeAlternatives_1_0.eContents().get(2);
		private final RuleCall cTypeChoiceParserRuleCall_1_0_3 = (RuleCall)cTypeAlternatives_1_0.eContents().get(3);
		private final RuleCall cTypeExistentialParserRuleCall_1_0_4 = (RuleCall)cTypeAlternatives_1_0.eContents().get(4);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cForConfigurationsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cFeaturesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cFeaturesFeatureCrossReference_2_1_0 = (CrossReference)cFeaturesAssignment_2_1.eContents().get(0);
		private final RuleCall cFeaturesFeatureIDTerminalRuleCall_2_1_0_1 = (RuleCall)cFeaturesFeatureCrossReference_2_1_0.eContents().get(1);
		
		///*
		//    templates can be divided into two main groups: existence templates
		//    and relation templates. The former is a set of unary templates. They can be
		//    expressed as predicates over one variable. The latter comprises rules that are
		//    imposed on target activities, when activation tasks occur. Relation templates
		//    thus correspond to binary predicates over two variables.
		// */
		//Templates:
		//    // name = ID type += (Existential | Relation | Coupling | Negative | Choice)+ ('for-configurations' features += [Feature|ID]+)?
		//    name = ID type += ( Dependencies | Past | Future | Choice | Existential)+ ('for-configurations' features += [Feature|ID]+)?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//// name = ID type += (Existential | Relation | Coupling | Negative | Choice)+ ('for-configurations' features += [Feature|ID]+)?
		//name = ID type += ( Dependencies | Past | Future | Choice | Existential)+ ('for-configurations' features += [Feature|ID]+)?
		public Group getGroup() { return cGroup; }
		
		//// name = ID type += (Existential | Relation | Coupling | Negative | Choice)+ ('for-configurations' features += [Feature|ID]+)?
		//name = ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//type += ( Dependencies | Past | Future | Choice | Existential)+
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//( Dependencies | Past | Future | Choice | Existential)
		public Alternatives getTypeAlternatives_1_0() { return cTypeAlternatives_1_0; }
		
		//Dependencies
		public RuleCall getTypeDependenciesParserRuleCall_1_0_0() { return cTypeDependenciesParserRuleCall_1_0_0; }
		
		//Past
		public RuleCall getTypePastParserRuleCall_1_0_1() { return cTypePastParserRuleCall_1_0_1; }
		
		//Future
		public RuleCall getTypeFutureParserRuleCall_1_0_2() { return cTypeFutureParserRuleCall_1_0_2; }
		
		//Choice
		public RuleCall getTypeChoiceParserRuleCall_1_0_3() { return cTypeChoiceParserRuleCall_1_0_3; }
		
		//Existential
		public RuleCall getTypeExistentialParserRuleCall_1_0_4() { return cTypeExistentialParserRuleCall_1_0_4; }
		
		//('for-configurations' features += [Feature|ID]+)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'for-configurations'
		public Keyword getForConfigurationsKeyword_2_0() { return cForConfigurationsKeyword_2_0; }
		
		//features += [Feature|ID]+
		public Assignment getFeaturesAssignment_2_1() { return cFeaturesAssignment_2_1; }
		
		//[Feature|ID]
		public CrossReference getFeaturesFeatureCrossReference_2_1_0() { return cFeaturesFeatureCrossReference_2_1_0; }
		
		//ID
		public RuleCall getFeaturesFeatureIDTerminalRuleCall_2_1_0_1() { return cFeaturesFeatureIDTerminalRuleCall_2_1_0_1; }
	}
	public class PastElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Past");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cTypeAlternatives_1_0 = (Alternatives)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cTypePrecedenceParserRuleCall_1_0_0 = (RuleCall)cTypeAlternatives_1_0.eContents().get(0);
		private final RuleCall cTypeAlternatePrecedenceParserRuleCall_1_0_1 = (RuleCall)cTypeAlternatives_1_0.eContents().get(1);
		private final RuleCall cTypeChainPrecedenceParserRuleCall_1_0_2 = (RuleCall)cTypeAlternatives_1_0.eContents().get(2);
		
		//Past:
		//    'P'
		//    type += (Precedence | AlternatePrecedence | ChainPrecedence)+
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'P'
		//type += (Precedence | AlternatePrecedence | ChainPrecedence)+
		public Group getGroup() { return cGroup; }
		
		//'P'
		public Keyword getPKeyword_0() { return cPKeyword_0; }
		
		//type += (Precedence | AlternatePrecedence | ChainPrecedence)+
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//(Precedence | AlternatePrecedence | ChainPrecedence)
		public Alternatives getTypeAlternatives_1_0() { return cTypeAlternatives_1_0; }
		
		//Precedence
		public RuleCall getTypePrecedenceParserRuleCall_1_0_0() { return cTypePrecedenceParserRuleCall_1_0_0; }
		
		//AlternatePrecedence
		public RuleCall getTypeAlternatePrecedenceParserRuleCall_1_0_1() { return cTypeAlternatePrecedenceParserRuleCall_1_0_1; }
		
		//ChainPrecedence
		public RuleCall getTypeChainPrecedenceParserRuleCall_1_0_2() { return cTypeChainPrecedenceParserRuleCall_1_0_2; }
	}
	public class FutureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Future");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cTypeAlternatives_1_0 = (Alternatives)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cTypeResponseParserRuleCall_1_0_0 = (RuleCall)cTypeAlternatives_1_0.eContents().get(0);
		private final RuleCall cTypeAlternateResponseParserRuleCall_1_0_1 = (RuleCall)cTypeAlternatives_1_0.eContents().get(1);
		private final RuleCall cTypeChainResponseParserRuleCall_1_0_2 = (RuleCall)cTypeAlternatives_1_0.eContents().get(2);
		
		//Future:
		//    'F'
		//    type += (Response | AlternateResponse | ChainResponse)+
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'F'
		//type += (Response | AlternateResponse | ChainResponse)+
		public Group getGroup() { return cGroup; }
		
		//'F'
		public Keyword getFKeyword_0() { return cFKeyword_0; }
		
		//type += (Response | AlternateResponse | ChainResponse)+
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//(Response | AlternateResponse | ChainResponse)
		public Alternatives getTypeAlternatives_1_0() { return cTypeAlternatives_1_0; }
		
		//Response
		public RuleCall getTypeResponseParserRuleCall_1_0_0() { return cTypeResponseParserRuleCall_1_0_0; }
		
		//AlternateResponse
		public RuleCall getTypeAlternateResponseParserRuleCall_1_0_1() { return cTypeAlternateResponseParserRuleCall_1_0_1; }
		
		//ChainResponse
		public RuleCall getTypeChainResponseParserRuleCall_1_0_2() { return cTypeChainResponseParserRuleCall_1_0_2; }
	}
	public class DependenciesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Dependencies");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPFKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cTypeAlternatives_1_0 = (Alternatives)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cTypeSuccessionParserRuleCall_1_0_0 = (RuleCall)cTypeAlternatives_1_0.eContents().get(0);
		private final RuleCall cTypeCoExistanceParserRuleCall_1_0_1 = (RuleCall)cTypeAlternatives_1_0.eContents().get(1);
		private final RuleCall cTypeAlternateSuccessionParserRuleCall_1_0_2 = (RuleCall)cTypeAlternatives_1_0.eContents().get(2);
		private final RuleCall cTypeChainSuccessionParserRuleCall_1_0_3 = (RuleCall)cTypeAlternatives_1_0.eContents().get(3);
		private final RuleCall cTypeRespondedExistenceParserRuleCall_1_0_4 = (RuleCall)cTypeAlternatives_1_0.eContents().get(4);
		private final RuleCall cTypeNotSuccessionParserRuleCall_1_0_5 = (RuleCall)cTypeAlternatives_1_0.eContents().get(5);
		private final RuleCall cTypeNotCoExistanceParserRuleCall_1_0_6 = (RuleCall)cTypeAlternatives_1_0.eContents().get(6);
		private final RuleCall cTypeNotChainSuccessionParserRuleCall_1_0_7 = (RuleCall)cTypeAlternatives_1_0.eContents().get(7);
		
		//Dependencies:
		//    'PF'
		//    type += (Succession  | CoExistance |AlternateSuccession  | ChainSuccession
		//            | RespondedExistence | NotSuccession | NotCoExistance | NotChainSuccession )+
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'PF'
		//type += (Succession  | CoExistance |AlternateSuccession  | ChainSuccession
		//        | RespondedExistence | NotSuccession | NotCoExistance | NotChainSuccession )+
		public Group getGroup() { return cGroup; }
		
		//'PF'
		public Keyword getPFKeyword_0() { return cPFKeyword_0; }
		
		//type += (Succession  | CoExistance |AlternateSuccession  | ChainSuccession
		//        | RespondedExistence | NotSuccession | NotCoExistance | NotChainSuccession )+
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//(Succession  | CoExistance |AlternateSuccession  | ChainSuccession
		//           | RespondedExistence | NotSuccession | NotCoExistance | NotChainSuccession )
		public Alternatives getTypeAlternatives_1_0() { return cTypeAlternatives_1_0; }
		
		//Succession
		public RuleCall getTypeSuccessionParserRuleCall_1_0_0() { return cTypeSuccessionParserRuleCall_1_0_0; }
		
		//CoExistance
		public RuleCall getTypeCoExistanceParserRuleCall_1_0_1() { return cTypeCoExistanceParserRuleCall_1_0_1; }
		
		//AlternateSuccession
		public RuleCall getTypeAlternateSuccessionParserRuleCall_1_0_2() { return cTypeAlternateSuccessionParserRuleCall_1_0_2; }
		
		//ChainSuccession
		public RuleCall getTypeChainSuccessionParserRuleCall_1_0_3() { return cTypeChainSuccessionParserRuleCall_1_0_3; }
		
		//RespondedExistence
		public RuleCall getTypeRespondedExistenceParserRuleCall_1_0_4() { return cTypeRespondedExistenceParserRuleCall_1_0_4; }
		
		//NotSuccession
		public RuleCall getTypeNotSuccessionParserRuleCall_1_0_5() { return cTypeNotSuccessionParserRuleCall_1_0_5; }
		
		//NotCoExistance
		public RuleCall getTypeNotCoExistanceParserRuleCall_1_0_6() { return cTypeNotCoExistanceParserRuleCall_1_0_6; }
		
		//NotChainSuccession
		public RuleCall getTypeNotChainSuccessionParserRuleCall_1_0_7() { return cTypeNotChainSuccessionParserRuleCall_1_0_7; }
	}
	public class ChoiceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Choice");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cTypeAlternatives_1_0 = (Alternatives)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cTypeSimpleChoiceParserRuleCall_1_0_0 = (RuleCall)cTypeAlternatives_1_0.eContents().get(0);
		private final RuleCall cTypeExclusiveChoiceParserRuleCall_1_0_1 = (RuleCall)cTypeAlternatives_1_0.eContents().get(1);
		
		//Choice:
		//    'C'
		//    type += (SimpleChoice | ExclusiveChoice) +
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'C'
		//type += (SimpleChoice | ExclusiveChoice) +
		public Group getGroup() { return cGroup; }
		
		//'C'
		public Keyword getCKeyword_0() { return cCKeyword_0; }
		
		//type += (SimpleChoice | ExclusiveChoice) +
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//(SimpleChoice | ExclusiveChoice)
		public Alternatives getTypeAlternatives_1_0() { return cTypeAlternatives_1_0; }
		
		//SimpleChoice
		public RuleCall getTypeSimpleChoiceParserRuleCall_1_0_0() { return cTypeSimpleChoiceParserRuleCall_1_0_0; }
		
		//ExclusiveChoice
		public RuleCall getTypeExclusiveChoiceParserRuleCall_1_0_1() { return cTypeExclusiveChoiceParserRuleCall_1_0_1; }
	}
	public class ExistentialElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Existential");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cTypeAlternatives_1_0 = (Alternatives)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cTypeAtLeastParserRuleCall_1_0_0 = (RuleCall)cTypeAlternatives_1_0.eContents().get(0);
		private final RuleCall cTypeAtMostParserRuleCall_1_0_1 = (RuleCall)cTypeAlternatives_1_0.eContents().get(1);
		private final RuleCall cTypeInitParserRuleCall_1_0_2 = (RuleCall)cTypeAlternatives_1_0.eContents().get(2);
		private final RuleCall cTypeEndParserRuleCall_1_0_3 = (RuleCall)cTypeAlternatives_1_0.eContents().get(3);
		private final RuleCall cTypeExactParserRuleCall_1_0_4 = (RuleCall)cTypeAlternatives_1_0.eContents().get(4);
		
		//Existential:
		//    'E'
		//    type += (AtLeast | AtMost | Init | End | Exact)+
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'E'
		//type += (AtLeast | AtMost | Init | End | Exact)+
		public Group getGroup() { return cGroup; }
		
		//'E'
		public Keyword getEKeyword_0() { return cEKeyword_0; }
		
		//type += (AtLeast | AtMost | Init | End | Exact)+
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//(AtLeast | AtMost | Init | End | Exact)
		public Alternatives getTypeAlternatives_1_0() { return cTypeAlternatives_1_0; }
		
		//AtLeast
		public RuleCall getTypeAtLeastParserRuleCall_1_0_0() { return cTypeAtLeastParserRuleCall_1_0_0; }
		
		//AtMost
		public RuleCall getTypeAtMostParserRuleCall_1_0_1() { return cTypeAtMostParserRuleCall_1_0_1; }
		
		//Init
		public RuleCall getTypeInitParserRuleCall_1_0_2() { return cTypeInitParserRuleCall_1_0_2; }
		
		//End
		public RuleCall getTypeEndParserRuleCall_1_0_3() { return cTypeEndParserRuleCall_1_0_3; }
		
		//Exact
		public RuleCall getTypeExactParserRuleCall_1_0_4() { return cTypeExactParserRuleCall_1_0_4; }
	}
	public class ExclusiveChoiceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.ExclusiveChoice");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEitherAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cEitherAEitherKeyword_0_0 = (Keyword)cEitherAAssignment_0.eContents().get(0);
		private final Assignment cRefAAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRefARefParserRuleCall_1_0 = (RuleCall)cRefAAssignment_1.eContents().get(0);
		private final Keyword cOrKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cEitherBAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cEitherBEitherKeyword_3_0 = (Keyword)cEitherBAssignment_3.eContents().get(0);
		private final Assignment cRefBAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRefBRefParserRuleCall_4_0 = (RuleCall)cRefBAssignment_4.eContents().get(0);
		private final Keyword cEventuallyOccurButNotTogetherKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//// Choice
		//ExclusiveChoice:
		//    eitherA?= 'either'? refA += Ref+ 'or' eitherB?= 'either'? refB += Ref+ 'eventually-occur-but-not-together'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//eitherA?= 'either'? refA += Ref+ 'or' eitherB?= 'either'? refB += Ref+ 'eventually-occur-but-not-together'
		public Group getGroup() { return cGroup; }
		
		//eitherA?= 'either'?
		public Assignment getEitherAAssignment_0() { return cEitherAAssignment_0; }
		
		//'either'
		public Keyword getEitherAEitherKeyword_0_0() { return cEitherAEitherKeyword_0_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_1() { return cRefAAssignment_1; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_1_0() { return cRefARefParserRuleCall_1_0; }
		
		//'or'
		public Keyword getOrKeyword_2() { return cOrKeyword_2; }
		
		//eitherB?= 'either'?
		public Assignment getEitherBAssignment_3() { return cEitherBAssignment_3; }
		
		//'either'
		public Keyword getEitherBEitherKeyword_3_0() { return cEitherBEitherKeyword_3_0; }
		
		//refB += Ref+
		public Assignment getRefBAssignment_4() { return cRefBAssignment_4; }
		
		//Ref
		public RuleCall getRefBRefParserRuleCall_4_0() { return cRefBRefParserRuleCall_4_0; }
		
		//'eventually-occur-but-not-together'
		public Keyword getEventuallyOccurButNotTogetherKeyword_5() { return cEventuallyOccurButNotTogetherKeyword_5; }
	}
	public class SimpleChoiceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.SimpleChoice");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRefARefParserRuleCall_0_0 = (RuleCall)cRefAAssignment_0.eContents().get(0);
		private final Keyword cEventuallyOccurKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//SimpleChoice:
		//    refA += Ref+ 'eventually-occur'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//refA += Ref+ 'eventually-occur'
		public Group getGroup() { return cGroup; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_0() { return cRefAAssignment_0; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_0_0() { return cRefARefParserRuleCall_0_0; }
		
		//'eventually-occur'
		public Keyword getEventuallyOccurKeyword_1() { return cEventuallyOccurKeyword_1; }
	}
	public class NotChainSuccessionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.NotChainSuccession");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkLessThanSignGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEitherAAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cEitherAEitherKeyword_1_0 = (Keyword)cEitherAAssignment_1.eContents().get(0);
		private final Assignment cRefAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRefARefParserRuleCall_2_0 = (RuleCall)cRefAAssignment_2.eContents().get(0);
		private final Keyword cOccursKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cIfAndOnlyIfNotFollowedImmediatelyByKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cEitherBAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Keyword cEitherBEitherKeyword_5_0 = (Keyword)cEitherBAssignment_5.eContents().get(0);
		private final Assignment cRefBAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cRefBRefParserRuleCall_6_0 = (RuleCall)cRefBAssignment_6.eContents().get(0);
		
		//// NEGATION //
		//// A (or | and C..) occurs if and only if not followed immediately by B (or | and D..)
		//NotChainSuccession:
		//    '!<>' eitherA?= 'either'? refA += Ref+ ('occurs')? 'if-and-only-if-not-followed-immediately-by' eitherB?= 'either'? refB += Ref+
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'!<>' eitherA?= 'either'? refA += Ref+ ('occurs')? 'if-and-only-if-not-followed-immediately-by' eitherB?= 'either'? refB += Ref+
		public Group getGroup() { return cGroup; }
		
		//'!<>'
		public Keyword getExclamationMarkLessThanSignGreaterThanSignKeyword_0() { return cExclamationMarkLessThanSignGreaterThanSignKeyword_0; }
		
		//eitherA?= 'either'?
		public Assignment getEitherAAssignment_1() { return cEitherAAssignment_1; }
		
		//'either'
		public Keyword getEitherAEitherKeyword_1_0() { return cEitherAEitherKeyword_1_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_2() { return cRefAAssignment_2; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_2_0() { return cRefARefParserRuleCall_2_0; }
		
		//('occurs')?
		public Keyword getOccursKeyword_3() { return cOccursKeyword_3; }
		
		//'if-and-only-if-not-followed-immediately-by'
		public Keyword getIfAndOnlyIfNotFollowedImmediatelyByKeyword_4() { return cIfAndOnlyIfNotFollowedImmediatelyByKeyword_4; }
		
		//eitherB?= 'either'?
		public Assignment getEitherBAssignment_5() { return cEitherBAssignment_5; }
		
		//'either'
		public Keyword getEitherBEitherKeyword_5_0() { return cEitherBEitherKeyword_5_0; }
		
		//refB += Ref+
		public Assignment getRefBAssignment_6() { return cRefBAssignment_6; }
		
		//Ref
		public RuleCall getRefBRefParserRuleCall_6_0() { return cRefBRefParserRuleCall_6_0; }
	}
	public class NotCoExistanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.NotCoExistance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRefAAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRefARefParserRuleCall_1_0 = (RuleCall)cRefAAssignment_1.eContents().get(0);
		private final Keyword cDoNotOccurTogetherKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		////A and B (and C..) do not occur together (implies exclusive choice)
		//NotCoExistance:
		//    '!-'refA += Ref+ 'do-not-occur-together'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'!-'refA += Ref+ 'do-not-occur-together'
		public Group getGroup() { return cGroup; }
		
		//'!-'
		public Keyword getExclamationMarkHyphenMinusKeyword_0() { return cExclamationMarkHyphenMinusKeyword_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_1() { return cRefAAssignment_1; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_1_0() { return cRefARefParserRuleCall_1_0; }
		
		//'do-not-occur-together'
		public Keyword getDoNotOccurTogetherKeyword_2() { return cDoNotOccurTogetherKeyword_2; }
	}
	public class NotSuccessionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.NotSuccession");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkLessThanSignHyphenMinusHyphenMinusGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEitherAAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cEitherAEitherKeyword_1_0 = (Keyword)cEitherAAssignment_1.eContents().get(0);
		private final Assignment cRefAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRefARefParserRuleCall_2_0 = (RuleCall)cRefAAssignment_2.eContents().get(0);
		private final Keyword cOccursKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cIfAndOnlyIfNotFollowedByKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cEitherBAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Keyword cEitherBEitherKeyword_5_0 = (Keyword)cEitherBAssignment_5.eContents().get(0);
		private final Assignment cRefBAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cRefBRefParserRuleCall_6_0 = (RuleCall)cRefBAssignment_6.eContents().get(0);
		
		//// A (or | and C..) occurs if and only if not followed by B (or | and C..)
		//NotSuccession:
		//    '!<-->' eitherA?= 'either'? refA += Ref+ ('occurs')?
		//    'if-and-only-if-not-followed-by' eitherB?= 'either'? refB += Ref+
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'!<-->' eitherA?= 'either'? refA += Ref+ ('occurs')?
		//'if-and-only-if-not-followed-by' eitherB?= 'either'? refB += Ref+
		public Group getGroup() { return cGroup; }
		
		//'!<-->'
		public Keyword getExclamationMarkLessThanSignHyphenMinusHyphenMinusGreaterThanSignKeyword_0() { return cExclamationMarkLessThanSignHyphenMinusHyphenMinusGreaterThanSignKeyword_0; }
		
		//eitherA?= 'either'?
		public Assignment getEitherAAssignment_1() { return cEitherAAssignment_1; }
		
		//'either'
		public Keyword getEitherAEitherKeyword_1_0() { return cEitherAEitherKeyword_1_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_2() { return cRefAAssignment_2; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_2_0() { return cRefARefParserRuleCall_2_0; }
		
		//('occurs')?
		public Keyword getOccursKeyword_3() { return cOccursKeyword_3; }
		
		//'if-and-only-if-not-followed-by'
		public Keyword getIfAndOnlyIfNotFollowedByKeyword_4() { return cIfAndOnlyIfNotFollowedByKeyword_4; }
		
		//eitherB?= 'either'?
		public Assignment getEitherBAssignment_5() { return cEitherBAssignment_5; }
		
		//'either'
		public Keyword getEitherBEitherKeyword_5_0() { return cEitherBEitherKeyword_5_0; }
		
		//refB += Ref+
		public Assignment getRefBAssignment_6() { return cRefBAssignment_6; }
		
		//Ref
		public RuleCall getRefBRefParserRuleCall_6_0() { return cRefBRefParserRuleCall_6_0; }
	}
	public class ChainSuccessionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.ChainSuccession");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEitherAAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cEitherAEitherKeyword_1_0 = (Keyword)cEitherAAssignment_1.eContents().get(0);
		private final Assignment cRefAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRefARefParserRuleCall_2_0 = (RuleCall)cRefAAssignment_2.eContents().get(0);
		private final Keyword cOccursIfAndOnlyIfImmediatelyFollowedByKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cEitherBAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Keyword cEitherBEitherKeyword_4_0 = (Keyword)cEitherBAssignment_4.eContents().get(0);
		private final Assignment cRefBAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cRefBRefParserRuleCall_5_0 = (RuleCall)cRefBAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cWithinKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cMinValAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cMinValINTTerminalRuleCall_6_1_0 = (RuleCall)cMinValAssignment_6_1.eContents().get(0);
		private final Group cGroup_6_2 = (Group)cGroup_6.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_6_2_0 = (Keyword)cGroup_6_2.eContents().get(0);
		private final Assignment cMaxValAssignment_6_2_1 = (Assignment)cGroup_6_2.eContents().get(1);
		private final RuleCall cMaxValINTTerminalRuleCall_6_2_1_0 = (RuleCall)cMaxValAssignment_6_2_1.eContents().get(0);
		private final Keyword cMsKeyword_6_3 = (Keyword)cGroup_6.eContents().get(3);
		
		///// TOGETHER ////
		//// A (or | and C..) occurs if and only if followed immediately by B (or | and D..)
		//ChainSuccession:
		//    '<>' eitherA?= 'either'? refA += Ref+ 'occurs-if-and-only-if-immediately-followed-by'
		//          eitherB?= 'either'? refB += Ref+ ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'<>' eitherA?= 'either'? refA += Ref+ 'occurs-if-and-only-if-immediately-followed-by'
		//      eitherB?= 'either'? refB += Ref+ ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup() { return cGroup; }
		
		//'<>'
		public Keyword getLessThanSignGreaterThanSignKeyword_0() { return cLessThanSignGreaterThanSignKeyword_0; }
		
		//eitherA?= 'either'?
		public Assignment getEitherAAssignment_1() { return cEitherAAssignment_1; }
		
		//'either'
		public Keyword getEitherAEitherKeyword_1_0() { return cEitherAEitherKeyword_1_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_2() { return cRefAAssignment_2; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_2_0() { return cRefARefParserRuleCall_2_0; }
		
		//'occurs-if-and-only-if-immediately-followed-by'
		public Keyword getOccursIfAndOnlyIfImmediatelyFollowedByKeyword_3() { return cOccursIfAndOnlyIfImmediatelyFollowedByKeyword_3; }
		
		//eitherB?= 'either'?
		public Assignment getEitherBAssignment_4() { return cEitherBAssignment_4; }
		
		//'either'
		public Keyword getEitherBEitherKeyword_4_0() { return cEitherBEitherKeyword_4_0; }
		
		//refB += Ref+
		public Assignment getRefBAssignment_5() { return cRefBAssignment_5; }
		
		//Ref
		public RuleCall getRefBRefParserRuleCall_5_0() { return cRefBRefParserRuleCall_5_0; }
		
		//('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup_6() { return cGroup_6; }
		
		//'within'
		public Keyword getWithinKeyword_6_0() { return cWithinKeyword_6_0; }
		
		//minVal = INT
		public Assignment getMinValAssignment_6_1() { return cMinValAssignment_6_1; }
		
		//INT
		public RuleCall getMinValINTTerminalRuleCall_6_1_0() { return cMinValINTTerminalRuleCall_6_1_0; }
		
		//('-' maxVal = INT)?
		public Group getGroup_6_2() { return cGroup_6_2; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_6_2_0() { return cHyphenMinusKeyword_6_2_0; }
		
		//maxVal = INT
		public Assignment getMaxValAssignment_6_2_1() { return cMaxValAssignment_6_2_1; }
		
		//INT
		public RuleCall getMaxValINTTerminalRuleCall_6_2_1_0() { return cMaxValINTTerminalRuleCall_6_2_1_0; }
		
		//'ms'
		public Keyword getMsKeyword_6_3() { return cMsKeyword_6_3; }
	}
	public class AlternateSuccessionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.AlternateSuccession");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignExclamationMarkGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEitherAAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cEitherAEitherKeyword_1_0 = (Keyword)cEitherAAssignment_1.eContents().get(0);
		private final Assignment cRefAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRefARefParserRuleCall_2_0 = (RuleCall)cRefAAssignment_2.eContents().get(0);
		private final Keyword cOccursKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cIfAndOnlyIfFollowedByKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cEitherBAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Keyword cEitherBEitherKeyword_5_0 = (Keyword)cEitherBAssignment_5.eContents().get(0);
		private final Assignment cRefBAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cRefBRefParserRuleCall_6_0 = (RuleCall)cRefBAssignment_6.eContents().get(0);
		private final Keyword cWithKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cEitherCAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final Keyword cEitherCEitherKeyword_8_0 = (Keyword)cEitherCAssignment_8.eContents().get(0);
		private final Assignment cNegationAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final Keyword cNegationNoKeyword_9_0 = (Keyword)cNegationAssignment_9.eContents().get(0);
		private final Assignment cRefCAssignment_10 = (Assignment)cGroup.eContents().get(10);
		private final RuleCall cRefCRefParserRuleCall_10_0 = (RuleCall)cRefCAssignment_10.eContents().get(0);
		private final Keyword cInBetweenKeyword_11 = (Keyword)cGroup.eContents().get(11);
		
		//// A occurs if and only if followed by B with no A and B (C, D) in between
		//AlternateSuccession:
		//    '<!>' eitherA?= 'either'? refA += Ref+ ('occurs')? 'if-and-only-if-followed-by'
		//          eitherB?= 'either'? refB += Ref+ 'with'
		//          eitherC?= 'either'? negation?= 'no'? refC += Ref+ 'in-between'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'<!>' eitherA?= 'either'? refA += Ref+ ('occurs')? 'if-and-only-if-followed-by'
		//      eitherB?= 'either'? refB += Ref+ 'with'
		//      eitherC?= 'either'? negation?= 'no'? refC += Ref+ 'in-between'
		public Group getGroup() { return cGroup; }
		
		//'<!>'
		public Keyword getLessThanSignExclamationMarkGreaterThanSignKeyword_0() { return cLessThanSignExclamationMarkGreaterThanSignKeyword_0; }
		
		//eitherA?= 'either'?
		public Assignment getEitherAAssignment_1() { return cEitherAAssignment_1; }
		
		//'either'
		public Keyword getEitherAEitherKeyword_1_0() { return cEitherAEitherKeyword_1_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_2() { return cRefAAssignment_2; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_2_0() { return cRefARefParserRuleCall_2_0; }
		
		//('occurs')?
		public Keyword getOccursKeyword_3() { return cOccursKeyword_3; }
		
		//'if-and-only-if-followed-by'
		public Keyword getIfAndOnlyIfFollowedByKeyword_4() { return cIfAndOnlyIfFollowedByKeyword_4; }
		
		//eitherB?= 'either'?
		public Assignment getEitherBAssignment_5() { return cEitherBAssignment_5; }
		
		//'either'
		public Keyword getEitherBEitherKeyword_5_0() { return cEitherBEitherKeyword_5_0; }
		
		//refB += Ref+
		public Assignment getRefBAssignment_6() { return cRefBAssignment_6; }
		
		//Ref
		public RuleCall getRefBRefParserRuleCall_6_0() { return cRefBRefParserRuleCall_6_0; }
		
		//'with'
		public Keyword getWithKeyword_7() { return cWithKeyword_7; }
		
		//eitherC?= 'either'?
		public Assignment getEitherCAssignment_8() { return cEitherCAssignment_8; }
		
		//'either'
		public Keyword getEitherCEitherKeyword_8_0() { return cEitherCEitherKeyword_8_0; }
		
		//negation?= 'no'?
		public Assignment getNegationAssignment_9() { return cNegationAssignment_9; }
		
		//'no'
		public Keyword getNegationNoKeyword_9_0() { return cNegationNoKeyword_9_0; }
		
		//refC += Ref+
		public Assignment getRefCAssignment_10() { return cRefCAssignment_10; }
		
		//Ref
		public RuleCall getRefCRefParserRuleCall_10_0() { return cRefCRefParserRuleCall_10_0; }
		
		//'in-between'
		public Keyword getInBetweenKeyword_11() { return cInBetweenKeyword_11; }
	}
	public class SuccessionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Succession");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignHyphenMinusHyphenMinusGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEitherAAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cEitherAEitherKeyword_1_0 = (Keyword)cEitherAAssignment_1.eContents().get(0);
		private final Assignment cRefAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRefARefParserRuleCall_2_0 = (RuleCall)cRefAAssignment_2.eContents().get(0);
		private final Keyword cOccursKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cIfAndOnlyIfFollowedByKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cEitherBAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Keyword cEitherBEitherKeyword_5_0 = (Keyword)cEitherBAssignment_5.eContents().get(0);
		private final Assignment cRefBAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cRefBRefParserRuleCall_6_0 = (RuleCall)cRefBAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cWithinKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cMinValAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cMinValINTTerminalRuleCall_7_1_0 = (RuleCall)cMinValAssignment_7_1.eContents().get(0);
		private final Group cGroup_7_2 = (Group)cGroup_7.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_7_2_0 = (Keyword)cGroup_7_2.eContents().get(0);
		private final Assignment cMaxValAssignment_7_2_1 = (Assignment)cGroup_7_2.eContents().get(1);
		private final RuleCall cMaxValINTTerminalRuleCall_7_2_1_0 = (RuleCall)cMaxValAssignment_7_2_1.eContents().get(0);
		private final Keyword cMsKeyword_7_3 = (Keyword)cGroup_7.eContents().get(3);
		
		//// A (or | and C..) occurs if and only if followed by B (or | and D..)
		//Succession:
		//    '<-->' eitherA?= 'either'? refA += Ref+ ('occurs')? 'if-and-only-if-followed-by'
		//           eitherB?= 'either'? refB += Ref+ ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'<-->' eitherA?= 'either'? refA += Ref+ ('occurs')? 'if-and-only-if-followed-by'
		//       eitherB?= 'either'? refB += Ref+ ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup() { return cGroup; }
		
		//'<-->'
		public Keyword getLessThanSignHyphenMinusHyphenMinusGreaterThanSignKeyword_0() { return cLessThanSignHyphenMinusHyphenMinusGreaterThanSignKeyword_0; }
		
		//eitherA?= 'either'?
		public Assignment getEitherAAssignment_1() { return cEitherAAssignment_1; }
		
		//'either'
		public Keyword getEitherAEitherKeyword_1_0() { return cEitherAEitherKeyword_1_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_2() { return cRefAAssignment_2; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_2_0() { return cRefARefParserRuleCall_2_0; }
		
		//('occurs')?
		public Keyword getOccursKeyword_3() { return cOccursKeyword_3; }
		
		//'if-and-only-if-followed-by'
		public Keyword getIfAndOnlyIfFollowedByKeyword_4() { return cIfAndOnlyIfFollowedByKeyword_4; }
		
		//eitherB?= 'either'?
		public Assignment getEitherBAssignment_5() { return cEitherBAssignment_5; }
		
		//'either'
		public Keyword getEitherBEitherKeyword_5_0() { return cEitherBEitherKeyword_5_0; }
		
		//refB += Ref+
		public Assignment getRefBAssignment_6() { return cRefBAssignment_6; }
		
		//Ref
		public RuleCall getRefBRefParserRuleCall_6_0() { return cRefBRefParserRuleCall_6_0; }
		
		//('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup_7() { return cGroup_7; }
		
		//'within'
		public Keyword getWithinKeyword_7_0() { return cWithinKeyword_7_0; }
		
		//minVal = INT
		public Assignment getMinValAssignment_7_1() { return cMinValAssignment_7_1; }
		
		//INT
		public RuleCall getMinValINTTerminalRuleCall_7_1_0() { return cMinValINTTerminalRuleCall_7_1_0; }
		
		//('-' maxVal = INT)?
		public Group getGroup_7_2() { return cGroup_7_2; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_7_2_0() { return cHyphenMinusKeyword_7_2_0; }
		
		//maxVal = INT
		public Assignment getMaxValAssignment_7_2_1() { return cMaxValAssignment_7_2_1; }
		
		//INT
		public RuleCall getMaxValINTTerminalRuleCall_7_2_1_0() { return cMaxValINTTerminalRuleCall_7_2_1_0; }
		
		//'ms'
		public Keyword getMsKeyword_7_3() { return cMsKeyword_7_3; }
	}
	public class CoExistanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.CoExistance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRefAAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRefARefParserRuleCall_1_0 = (RuleCall)cRefAAssignment_1.eContents().get(0);
		private final Keyword cOccurTogetherKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// A and B (and C..) occur together
		//CoExistance:
		//    '-' refA += Ref+ 'occur-together'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'-' refA += Ref+ 'occur-together'
		public Group getGroup() { return cGroup; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_1() { return cRefAAssignment_1; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_1_0() { return cRefARefParserRuleCall_1_0; }
		
		//'occur-together'
		public Keyword getOccurTogetherKeyword_2() { return cOccurTogetherKeyword_2; }
	}
	public class RespondedExistenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.RespondedExistence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusVerticalLineHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEitherAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cEitherAEitherKeyword_2_0 = (Keyword)cEitherAAssignment_2.eContents().get(0);
		private final Assignment cRefAAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRefARefParserRuleCall_3_0 = (RuleCall)cRefAAssignment_3.eContents().get(0);
		private final Keyword cOccursKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cThenKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cEitherBAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cEitherBEitherKeyword_6_0 = (Keyword)cEitherBAssignment_6.eContents().get(0);
		private final Assignment cRefBAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cRefBRefParserRuleCall_7_0 = (RuleCall)cRefBAssignment_7.eContents().get(0);
		private final Keyword cOccursAsWellKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//RespondedExistence:
		//    '-|-' 'if' eitherA?= 'either'? refA += Ref+ ('occurs')? 'then' eitherB?= 'either'? refB += Ref+ 'occurs-as-well'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'-|-' 'if' eitherA?= 'either'? refA += Ref+ ('occurs')? 'then' eitherB?= 'either'? refB += Ref+ 'occurs-as-well'
		public Group getGroup() { return cGroup; }
		
		//'-|-'
		public Keyword getHyphenMinusVerticalLineHyphenMinusKeyword_0() { return cHyphenMinusVerticalLineHyphenMinusKeyword_0; }
		
		//'if'
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }
		
		//eitherA?= 'either'?
		public Assignment getEitherAAssignment_2() { return cEitherAAssignment_2; }
		
		//'either'
		public Keyword getEitherAEitherKeyword_2_0() { return cEitherAEitherKeyword_2_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_3() { return cRefAAssignment_3; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_3_0() { return cRefARefParserRuleCall_3_0; }
		
		//('occurs')?
		public Keyword getOccursKeyword_4() { return cOccursKeyword_4; }
		
		//'then'
		public Keyword getThenKeyword_5() { return cThenKeyword_5; }
		
		//eitherB?= 'either'?
		public Assignment getEitherBAssignment_6() { return cEitherBAssignment_6; }
		
		//'either'
		public Keyword getEitherBEitherKeyword_6_0() { return cEitherBEitherKeyword_6_0; }
		
		//refB += Ref+
		public Assignment getRefBAssignment_7() { return cRefBAssignment_7; }
		
		//Ref
		public RuleCall getRefBRefParserRuleCall_7_0() { return cRefBRefParserRuleCall_7_0; }
		
		//'occurs-as-well'
		public Keyword getOccursAsWellKeyword_8() { return cOccursAsWellKeyword_8; }
	}
	public class ChainPrecedenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.ChainPrecedence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cWheneverKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEitherBAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cEitherBEitherKeyword_2_0 = (Keyword)cEitherBAssignment_2.eContents().get(0);
		private final Assignment cRefBAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRefBRefParserRuleCall_3_0 = (RuleCall)cRefBAssignment_3.eContents().get(0);
		private final Keyword cOccursKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cThenKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cEitherAAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cEitherAEitherKeyword_6_0 = (Keyword)cEitherAAssignment_6.eContents().get(0);
		private final Assignment cRefAAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cRefARefParserRuleCall_7_0 = (RuleCall)cRefAAssignment_7.eContents().get(0);
		private final Keyword cMustKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cNotAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final Keyword cNotNotKeyword_9_0 = (Keyword)cNotAssignment_9.eContents().get(0);
		private final Keyword cHaveOccurredImmediatelyBeforeKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Group cGroup_11 = (Group)cGroup.eContents().get(11);
		private final Keyword cWithinKeyword_11_0 = (Keyword)cGroup_11.eContents().get(0);
		private final Assignment cMinValAssignment_11_1 = (Assignment)cGroup_11.eContents().get(1);
		private final RuleCall cMinValINTTerminalRuleCall_11_1_0 = (RuleCall)cMinValAssignment_11_1.eContents().get(0);
		private final Group cGroup_11_2 = (Group)cGroup_11.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_11_2_0 = (Keyword)cGroup_11_2.eContents().get(0);
		private final Assignment cMaxValAssignment_11_2_1 = (Assignment)cGroup_11_2.eContents().get(1);
		private final RuleCall cMaxValINTTerminalRuleCall_11_2_1_0 = (RuleCall)cMaxValAssignment_11_2_1.eContents().get(0);
		private final Keyword cMsKeyword_11_3 = (Keyword)cGroup_11.eContents().get(3);
		
		//////// RELATION ////////
		//// Whenever B (OR|AND D...) occurs then A (OR|AND C..) must (not) immediately precede it
		//ChainPrecedence:
		//    '<' 'whenever' eitherB?= 'either'? refB += Ref+ ('occurs')?
		//    'then' eitherA?= 'either'? refA += Ref+ 'must' not?= 'not'?
		//    'have-occurred-immediately-before' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'<' 'whenever' eitherB?= 'either'? refB += Ref+ ('occurs')?
		//'then' eitherA?= 'either'? refA += Ref+ 'must' not?= 'not'?
		//'have-occurred-immediately-before' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup() { return cGroup; }
		
		//'<'
		public Keyword getLessThanSignKeyword_0() { return cLessThanSignKeyword_0; }
		
		//'whenever'
		public Keyword getWheneverKeyword_1() { return cWheneverKeyword_1; }
		
		//eitherB?= 'either'?
		public Assignment getEitherBAssignment_2() { return cEitherBAssignment_2; }
		
		//'either'
		public Keyword getEitherBEitherKeyword_2_0() { return cEitherBEitherKeyword_2_0; }
		
		//refB += Ref+
		public Assignment getRefBAssignment_3() { return cRefBAssignment_3; }
		
		//Ref
		public RuleCall getRefBRefParserRuleCall_3_0() { return cRefBRefParserRuleCall_3_0; }
		
		//('occurs')?
		public Keyword getOccursKeyword_4() { return cOccursKeyword_4; }
		
		//'then'
		public Keyword getThenKeyword_5() { return cThenKeyword_5; }
		
		//eitherA?= 'either'?
		public Assignment getEitherAAssignment_6() { return cEitherAAssignment_6; }
		
		//'either'
		public Keyword getEitherAEitherKeyword_6_0() { return cEitherAEitherKeyword_6_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_7() { return cRefAAssignment_7; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_7_0() { return cRefARefParserRuleCall_7_0; }
		
		//'must'
		public Keyword getMustKeyword_8() { return cMustKeyword_8; }
		
		//not?= 'not'?
		public Assignment getNotAssignment_9() { return cNotAssignment_9; }
		
		//'not'
		public Keyword getNotNotKeyword_9_0() { return cNotNotKeyword_9_0; }
		
		//'have-occurred-immediately-before'
		public Keyword getHaveOccurredImmediatelyBeforeKeyword_10() { return cHaveOccurredImmediatelyBeforeKeyword_10; }
		
		//('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup_11() { return cGroup_11; }
		
		//'within'
		public Keyword getWithinKeyword_11_0() { return cWithinKeyword_11_0; }
		
		//minVal = INT
		public Assignment getMinValAssignment_11_1() { return cMinValAssignment_11_1; }
		
		//INT
		public RuleCall getMinValINTTerminalRuleCall_11_1_0() { return cMinValINTTerminalRuleCall_11_1_0; }
		
		//('-' maxVal = INT)?
		public Group getGroup_11_2() { return cGroup_11_2; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_11_2_0() { return cHyphenMinusKeyword_11_2_0; }
		
		//maxVal = INT
		public Assignment getMaxValAssignment_11_2_1() { return cMaxValAssignment_11_2_1; }
		
		//INT
		public RuleCall getMaxValINTTerminalRuleCall_11_2_1_0() { return cMaxValINTTerminalRuleCall_11_2_1_0; }
		
		//'ms'
		public Keyword getMsKeyword_11_3() { return cMsKeyword_11_3; }
	}
	public class ChainResponseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.ChainResponse");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEitherAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cEitherAEitherKeyword_2_0 = (Keyword)cEitherAAssignment_2.eContents().get(0);
		private final Assignment cRefAAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRefARefParserRuleCall_3_0 = (RuleCall)cRefAAssignment_3.eContents().get(0);
		private final Keyword cOccursKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cThenKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cEitherBAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cEitherBEitherKeyword_6_0 = (Keyword)cEitherBAssignment_6.eContents().get(0);
		private final Assignment cRefBAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cRefBRefParserRuleCall_7_0 = (RuleCall)cRefBAssignment_7.eContents().get(0);
		private final Keyword cMustKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cNotAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final Keyword cNotNotKeyword_9_0 = (Keyword)cNotAssignment_9.eContents().get(0);
		private final Keyword cImmediatelyFollowKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Group cGroup_11 = (Group)cGroup.eContents().get(11);
		private final Keyword cWithinKeyword_11_0 = (Keyword)cGroup_11.eContents().get(0);
		private final Assignment cMinValAssignment_11_1 = (Assignment)cGroup_11.eContents().get(1);
		private final RuleCall cMinValINTTerminalRuleCall_11_1_0 = (RuleCall)cMinValAssignment_11_1.eContents().get(0);
		private final Group cGroup_11_2 = (Group)cGroup_11.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_11_2_0 = (Keyword)cGroup_11_2.eContents().get(0);
		private final Assignment cMaxValAssignment_11_2_1 = (Assignment)cGroup_11_2.eContents().get(1);
		private final RuleCall cMaxValINTTerminalRuleCall_11_2_1_0 = (RuleCall)cMaxValAssignment_11_2_1.eContents().get(0);
		private final Keyword cMsKeyword_11_3 = (Keyword)cGroup_11.eContents().get(3);
		
		//// If A (OR|AND C..) occurs then B (OR|AND D...) (does not) immediately follow
		//ChainResponse:
		//    '>' 'if' eitherA?= 'either'? refA += Ref+ ('occurs')?
		//    'then' eitherB?= 'either'? refB += Ref+ 'must' not?= 'not'?
		//    'immediately-follow' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'>' 'if' eitherA?= 'either'? refA += Ref+ ('occurs')?
		//'then' eitherB?= 'either'? refB += Ref+ 'must' not?= 'not'?
		//'immediately-follow' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup() { return cGroup; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_0() { return cGreaterThanSignKeyword_0; }
		
		//'if'
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }
		
		//eitherA?= 'either'?
		public Assignment getEitherAAssignment_2() { return cEitherAAssignment_2; }
		
		//'either'
		public Keyword getEitherAEitherKeyword_2_0() { return cEitherAEitherKeyword_2_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_3() { return cRefAAssignment_3; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_3_0() { return cRefARefParserRuleCall_3_0; }
		
		//('occurs')?
		public Keyword getOccursKeyword_4() { return cOccursKeyword_4; }
		
		//'then'
		public Keyword getThenKeyword_5() { return cThenKeyword_5; }
		
		//eitherB?= 'either'?
		public Assignment getEitherBAssignment_6() { return cEitherBAssignment_6; }
		
		//'either'
		public Keyword getEitherBEitherKeyword_6_0() { return cEitherBEitherKeyword_6_0; }
		
		//refB += Ref+
		public Assignment getRefBAssignment_7() { return cRefBAssignment_7; }
		
		//Ref
		public RuleCall getRefBRefParserRuleCall_7_0() { return cRefBRefParserRuleCall_7_0; }
		
		//'must'
		public Keyword getMustKeyword_8() { return cMustKeyword_8; }
		
		//not?= 'not'?
		public Assignment getNotAssignment_9() { return cNotAssignment_9; }
		
		//'not'
		public Keyword getNotNotKeyword_9_0() { return cNotNotKeyword_9_0; }
		
		//'immediately-follow'
		public Keyword getImmediatelyFollowKeyword_10() { return cImmediatelyFollowKeyword_10; }
		
		//('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup_11() { return cGroup_11; }
		
		//'within'
		public Keyword getWithinKeyword_11_0() { return cWithinKeyword_11_0; }
		
		//minVal = INT
		public Assignment getMinValAssignment_11_1() { return cMinValAssignment_11_1; }
		
		//INT
		public RuleCall getMinValINTTerminalRuleCall_11_1_0() { return cMinValINTTerminalRuleCall_11_1_0; }
		
		//('-' maxVal = INT)?
		public Group getGroup_11_2() { return cGroup_11_2; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_11_2_0() { return cHyphenMinusKeyword_11_2_0; }
		
		//maxVal = INT
		public Assignment getMaxValAssignment_11_2_1() { return cMaxValAssignment_11_2_1; }
		
		//INT
		public RuleCall getMaxValINTTerminalRuleCall_11_2_1_0() { return cMaxValINTTerminalRuleCall_11_2_1_0; }
		
		//'ms'
		public Keyword getMsKeyword_11_3() { return cMsKeyword_11_3; }
	}
	public class AlternateResponseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.AlternateResponse");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEitherAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cEitherAEitherKeyword_2_0 = (Keyword)cEitherAAssignment_2.eContents().get(0);
		private final Assignment cRefAAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRefARefParserRuleCall_3_0 = (RuleCall)cRefAAssignment_3.eContents().get(0);
		private final Keyword cOccursKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cThenKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cEitherBAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cEitherBEitherKeyword_6_0 = (Keyword)cEitherBAssignment_6.eContents().get(0);
		private final Assignment cRefBAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cRefBRefParserRuleCall_7_0 = (RuleCall)cRefBAssignment_7.eContents().get(0);
		private final Keyword cMustFollowKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Group cGroup_9 = (Group)cGroup.eContents().get(9);
		private final Keyword cWithinKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Assignment cMinValAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cMinValINTTerminalRuleCall_9_1_0 = (RuleCall)cMinValAssignment_9_1.eContents().get(0);
		private final Group cGroup_9_2 = (Group)cGroup_9.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_9_2_0 = (Keyword)cGroup_9_2.eContents().get(0);
		private final Assignment cMaxValAssignment_9_2_1 = (Assignment)cGroup_9_2.eContents().get(1);
		private final RuleCall cMaxValINTTerminalRuleCall_9_2_1_0 = (RuleCall)cMaxValAssignment_9_2_1.eContents().get(0);
		private final Keyword cMsKeyword_9_3 = (Keyword)cGroup_9.eContents().get(3);
		private final Keyword cWithKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Assignment cNotAssignment_11 = (Assignment)cGroup.eContents().get(11);
		private final Keyword cNotNoKeyword_11_0 = (Keyword)cNotAssignment_11.eContents().get(0);
		private final Assignment cEitherCAssignment_12 = (Assignment)cGroup.eContents().get(12);
		private final Keyword cEitherCEitherKeyword_12_0 = (Keyword)cEitherCAssignment_12.eContents().get(0);
		private final Assignment cRefCAssignment_13 = (Assignment)cGroup.eContents().get(13);
		private final RuleCall cRefCRefParserRuleCall_13_0 = (RuleCall)cRefCAssignment_13.eContents().get(0);
		private final Keyword cInBetweenKeyword_14 = (Keyword)cGroup.eContents().get(14);
		
		//// If A (OR|AND X...) occurs then B (OR|AND Y...) must follow with no (only) A (OR|AND X...) and C (OR|AND Z...) in between
		//AlternateResponse:
		//    '!>' 'if' eitherA?= 'either'? refA += Ref+ ('occurs')?
		//    'then' eitherB?= 'either'? refB += Ref+ 'must-follow' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		//    'with' not?= 'no'? eitherC?= 'either'? refC += Ref+ 'in-between'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'!>' 'if' eitherA?= 'either'? refA += Ref+ ('occurs')?
		//'then' eitherB?= 'either'? refB += Ref+ 'must-follow' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		//'with' not?= 'no'? eitherC?= 'either'? refC += Ref+ 'in-between'
		public Group getGroup() { return cGroup; }
		
		//'!>'
		public Keyword getExclamationMarkGreaterThanSignKeyword_0() { return cExclamationMarkGreaterThanSignKeyword_0; }
		
		//'if'
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }
		
		//eitherA?= 'either'?
		public Assignment getEitherAAssignment_2() { return cEitherAAssignment_2; }
		
		//'either'
		public Keyword getEitherAEitherKeyword_2_0() { return cEitherAEitherKeyword_2_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_3() { return cRefAAssignment_3; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_3_0() { return cRefARefParserRuleCall_3_0; }
		
		//('occurs')?
		public Keyword getOccursKeyword_4() { return cOccursKeyword_4; }
		
		//'then'
		public Keyword getThenKeyword_5() { return cThenKeyword_5; }
		
		//eitherB?= 'either'?
		public Assignment getEitherBAssignment_6() { return cEitherBAssignment_6; }
		
		//'either'
		public Keyword getEitherBEitherKeyword_6_0() { return cEitherBEitherKeyword_6_0; }
		
		//refB += Ref+
		public Assignment getRefBAssignment_7() { return cRefBAssignment_7; }
		
		//Ref
		public RuleCall getRefBRefParserRuleCall_7_0() { return cRefBRefParserRuleCall_7_0; }
		
		//'must-follow'
		public Keyword getMustFollowKeyword_8() { return cMustFollowKeyword_8; }
		
		//('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup_9() { return cGroup_9; }
		
		//'within'
		public Keyword getWithinKeyword_9_0() { return cWithinKeyword_9_0; }
		
		//minVal = INT
		public Assignment getMinValAssignment_9_1() { return cMinValAssignment_9_1; }
		
		//INT
		public RuleCall getMinValINTTerminalRuleCall_9_1_0() { return cMinValINTTerminalRuleCall_9_1_0; }
		
		//('-' maxVal = INT)?
		public Group getGroup_9_2() { return cGroup_9_2; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_9_2_0() { return cHyphenMinusKeyword_9_2_0; }
		
		//maxVal = INT
		public Assignment getMaxValAssignment_9_2_1() { return cMaxValAssignment_9_2_1; }
		
		//INT
		public RuleCall getMaxValINTTerminalRuleCall_9_2_1_0() { return cMaxValINTTerminalRuleCall_9_2_1_0; }
		
		//'ms'
		public Keyword getMsKeyword_9_3() { return cMsKeyword_9_3; }
		
		//'with'
		public Keyword getWithKeyword_10() { return cWithKeyword_10; }
		
		//not?= 'no'?
		public Assignment getNotAssignment_11() { return cNotAssignment_11; }
		
		//'no'
		public Keyword getNotNoKeyword_11_0() { return cNotNoKeyword_11_0; }
		
		//eitherC?= 'either'?
		public Assignment getEitherCAssignment_12() { return cEitherCAssignment_12; }
		
		//'either'
		public Keyword getEitherCEitherKeyword_12_0() { return cEitherCEitherKeyword_12_0; }
		
		//refC += Ref+
		public Assignment getRefCAssignment_13() { return cRefCAssignment_13; }
		
		//Ref
		public RuleCall getRefCRefParserRuleCall_13_0() { return cRefCRefParserRuleCall_13_0; }
		
		//'in-between'
		public Keyword getInBetweenKeyword_14() { return cInBetweenKeyword_14; }
	}
	public class AlternatePrecedenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.AlternatePrecedence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignExclamationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cWheneverKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEitherBAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cEitherBEitherKeyword_2_0 = (Keyword)cEitherBAssignment_2.eContents().get(0);
		private final Assignment cRefBAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRefBRefParserRuleCall_3_0 = (RuleCall)cRefBAssignment_3.eContents().get(0);
		private final Keyword cOccursKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cThenKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cEitherAAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cEitherAEitherKeyword_6_0 = (Keyword)cEitherAAssignment_6.eContents().get(0);
		private final Assignment cRefAAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cRefARefParserRuleCall_7_0 = (RuleCall)cRefAAssignment_7.eContents().get(0);
		private final Keyword cMustHaveOccurredKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Group cGroup_9 = (Group)cGroup.eContents().get(9);
		private final Keyword cWithinKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Assignment cMinValAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cMinValINTTerminalRuleCall_9_1_0 = (RuleCall)cMinValAssignment_9_1.eContents().get(0);
		private final Group cGroup_9_2 = (Group)cGroup_9.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_9_2_0 = (Keyword)cGroup_9_2.eContents().get(0);
		private final Assignment cMaxValAssignment_9_2_1 = (Assignment)cGroup_9_2.eContents().get(1);
		private final RuleCall cMaxValINTTerminalRuleCall_9_2_1_0 = (RuleCall)cMaxValAssignment_9_2_1.eContents().get(0);
		private final Keyword cMsKeyword_9_3 = (Keyword)cGroup_9.eContents().get(3);
		private final Keyword cWithKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Assignment cNotAssignment_11 = (Assignment)cGroup.eContents().get(11);
		private final Keyword cNotNoKeyword_11_0 = (Keyword)cNotAssignment_11.eContents().get(0);
		private final Assignment cEitherCAssignment_12 = (Assignment)cGroup.eContents().get(12);
		private final Keyword cEitherCEitherKeyword_12_0 = (Keyword)cEitherCAssignment_12.eContents().get(0);
		private final Assignment cRefCAssignment_13 = (Assignment)cGroup.eContents().get(13);
		private final RuleCall cRefCRefParserRuleCall_13_0 = (RuleCall)cRefCAssignment_13.eContents().get(0);
		private final Keyword cInBetweenKeyword_14 = (Keyword)cGroup.eContents().get(14);
		
		//// Whenever B (OR|AND Y...) occurs then A (OR|AND X...) must have occurred before with no B (OR|AND Y...) and C (OR|AND Z...) in between
		//AlternatePrecedence:
		//    '<!' 'whenever' eitherB?= 'either'? refB += Ref ('occurs')?
		//    'then' eitherA?= 'either'? refA += Ref 'must-have-occurred' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		//    'with' not?= 'no'? eitherC?= 'either'? refC += Ref 'in-between'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'<!' 'whenever' eitherB?= 'either'? refB += Ref ('occurs')?
		//'then' eitherA?= 'either'? refA += Ref 'must-have-occurred' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		//'with' not?= 'no'? eitherC?= 'either'? refC += Ref 'in-between'
		public Group getGroup() { return cGroup; }
		
		//'<!'
		public Keyword getLessThanSignExclamationMarkKeyword_0() { return cLessThanSignExclamationMarkKeyword_0; }
		
		//'whenever'
		public Keyword getWheneverKeyword_1() { return cWheneverKeyword_1; }
		
		//eitherB?= 'either'?
		public Assignment getEitherBAssignment_2() { return cEitherBAssignment_2; }
		
		//'either'
		public Keyword getEitherBEitherKeyword_2_0() { return cEitherBEitherKeyword_2_0; }
		
		//refB += Ref
		public Assignment getRefBAssignment_3() { return cRefBAssignment_3; }
		
		//Ref
		public RuleCall getRefBRefParserRuleCall_3_0() { return cRefBRefParserRuleCall_3_0; }
		
		//('occurs')?
		public Keyword getOccursKeyword_4() { return cOccursKeyword_4; }
		
		//'then'
		public Keyword getThenKeyword_5() { return cThenKeyword_5; }
		
		//eitherA?= 'either'?
		public Assignment getEitherAAssignment_6() { return cEitherAAssignment_6; }
		
		//'either'
		public Keyword getEitherAEitherKeyword_6_0() { return cEitherAEitherKeyword_6_0; }
		
		//refA += Ref
		public Assignment getRefAAssignment_7() { return cRefAAssignment_7; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_7_0() { return cRefARefParserRuleCall_7_0; }
		
		//'must-have-occurred'
		public Keyword getMustHaveOccurredKeyword_8() { return cMustHaveOccurredKeyword_8; }
		
		//('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup_9() { return cGroup_9; }
		
		//'within'
		public Keyword getWithinKeyword_9_0() { return cWithinKeyword_9_0; }
		
		//minVal = INT
		public Assignment getMinValAssignment_9_1() { return cMinValAssignment_9_1; }
		
		//INT
		public RuleCall getMinValINTTerminalRuleCall_9_1_0() { return cMinValINTTerminalRuleCall_9_1_0; }
		
		//('-' maxVal = INT)?
		public Group getGroup_9_2() { return cGroup_9_2; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_9_2_0() { return cHyphenMinusKeyword_9_2_0; }
		
		//maxVal = INT
		public Assignment getMaxValAssignment_9_2_1() { return cMaxValAssignment_9_2_1; }
		
		//INT
		public RuleCall getMaxValINTTerminalRuleCall_9_2_1_0() { return cMaxValINTTerminalRuleCall_9_2_1_0; }
		
		//'ms'
		public Keyword getMsKeyword_9_3() { return cMsKeyword_9_3; }
		
		//'with'
		public Keyword getWithKeyword_10() { return cWithKeyword_10; }
		
		//not?= 'no'?
		public Assignment getNotAssignment_11() { return cNotAssignment_11; }
		
		//'no'
		public Keyword getNotNoKeyword_11_0() { return cNotNoKeyword_11_0; }
		
		//eitherC?= 'either'?
		public Assignment getEitherCAssignment_12() { return cEitherCAssignment_12; }
		
		//'either'
		public Keyword getEitherCEitherKeyword_12_0() { return cEitherCEitherKeyword_12_0; }
		
		//refC += Ref
		public Assignment getRefCAssignment_13() { return cRefCAssignment_13; }
		
		//Ref
		public RuleCall getRefCRefParserRuleCall_13_0() { return cRefCRefParserRuleCall_13_0; }
		
		//'in-between'
		public Keyword getInBetweenKeyword_14() { return cInBetweenKeyword_14; }
	}
	public class ResponseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Response");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEitherAAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cEitherAEitherKeyword_2_0 = (Keyword)cEitherAAssignment_2.eContents().get(0);
		private final Assignment cRefAAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRefARefParserRuleCall_3_0 = (RuleCall)cRefAAssignment_3.eContents().get(0);
		private final Keyword cOccursKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cThenKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cEitherBAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cEitherBEitherKeyword_6_0 = (Keyword)cEitherBAssignment_6.eContents().get(0);
		private final Assignment cRefBAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cRefBRefParserRuleCall_7_0 = (RuleCall)cRefBAssignment_7.eContents().get(0);
		private final Keyword cMustKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cNotAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final Keyword cNotNotKeyword_9_0 = (Keyword)cNotAssignment_9.eContents().get(0);
		private final Keyword cEventuallyFollowKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Group cGroup_11 = (Group)cGroup.eContents().get(11);
		private final Keyword cWithinKeyword_11_0 = (Keyword)cGroup_11.eContents().get(0);
		private final Assignment cMinValAssignment_11_1 = (Assignment)cGroup_11.eContents().get(1);
		private final RuleCall cMinValINTTerminalRuleCall_11_1_0 = (RuleCall)cMinValAssignment_11_1.eContents().get(0);
		private final Group cGroup_11_2 = (Group)cGroup_11.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_11_2_0 = (Keyword)cGroup_11_2.eContents().get(0);
		private final Assignment cMaxValAssignment_11_2_1 = (Assignment)cGroup_11_2.eContents().get(1);
		private final RuleCall cMaxValINTTerminalRuleCall_11_2_1_0 = (RuleCall)cMaxValAssignment_11_2_1.eContents().get(0);
		private final Keyword cMsKeyword_11_3 = (Keyword)cGroup_11.eContents().get(3);
		
		//Response:
		//    '->' 'if' eitherA?= 'either'? refA += Ref+ ('occurs')?
		//    'then' eitherB?= 'either'? refB += Ref+ 'must' not?= 'not'?
		//    'eventually-follow' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'->' 'if' eitherA?= 'either'? refA += Ref+ ('occurs')?
		//'then' eitherB?= 'either'? refB += Ref+ 'must' not?= 'not'?
		//'eventually-follow' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup() { return cGroup; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_0() { return cHyphenMinusGreaterThanSignKeyword_0; }
		
		//'if'
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }
		
		//eitherA?= 'either'?
		public Assignment getEitherAAssignment_2() { return cEitherAAssignment_2; }
		
		//'either'
		public Keyword getEitherAEitherKeyword_2_0() { return cEitherAEitherKeyword_2_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_3() { return cRefAAssignment_3; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_3_0() { return cRefARefParserRuleCall_3_0; }
		
		//('occurs')?
		public Keyword getOccursKeyword_4() { return cOccursKeyword_4; }
		
		//'then'
		public Keyword getThenKeyword_5() { return cThenKeyword_5; }
		
		//eitherB?= 'either'?
		public Assignment getEitherBAssignment_6() { return cEitherBAssignment_6; }
		
		//'either'
		public Keyword getEitherBEitherKeyword_6_0() { return cEitherBEitherKeyword_6_0; }
		
		//refB += Ref+
		public Assignment getRefBAssignment_7() { return cRefBAssignment_7; }
		
		//Ref
		public RuleCall getRefBRefParserRuleCall_7_0() { return cRefBRefParserRuleCall_7_0; }
		
		//'must'
		public Keyword getMustKeyword_8() { return cMustKeyword_8; }
		
		//not?= 'not'?
		public Assignment getNotAssignment_9() { return cNotAssignment_9; }
		
		//'not'
		public Keyword getNotNotKeyword_9_0() { return cNotNotKeyword_9_0; }
		
		//'eventually-follow'
		public Keyword getEventuallyFollowKeyword_10() { return cEventuallyFollowKeyword_10; }
		
		//('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup_11() { return cGroup_11; }
		
		//'within'
		public Keyword getWithinKeyword_11_0() { return cWithinKeyword_11_0; }
		
		//minVal = INT
		public Assignment getMinValAssignment_11_1() { return cMinValAssignment_11_1; }
		
		//INT
		public RuleCall getMinValINTTerminalRuleCall_11_1_0() { return cMinValINTTerminalRuleCall_11_1_0; }
		
		//('-' maxVal = INT)?
		public Group getGroup_11_2() { return cGroup_11_2; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_11_2_0() { return cHyphenMinusKeyword_11_2_0; }
		
		//maxVal = INT
		public Assignment getMaxValAssignment_11_2_1() { return cMaxValAssignment_11_2_1; }
		
		//INT
		public RuleCall getMaxValINTTerminalRuleCall_11_2_1_0() { return cMaxValINTTerminalRuleCall_11_2_1_0; }
		
		//'ms'
		public Keyword getMsKeyword_11_3() { return cMsKeyword_11_3; }
	}
	public class PrecedenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Precedence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLessThanSignHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cWheneverKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEitherBAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cEitherBEitherKeyword_2_0 = (Keyword)cEitherBAssignment_2.eContents().get(0);
		private final Assignment cRefBAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRefBRefParserRuleCall_3_0 = (RuleCall)cRefBAssignment_3.eContents().get(0);
		private final Keyword cOccursKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cThenKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cEitherAAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cEitherAEitherKeyword_6_0 = (Keyword)cEitherAAssignment_6.eContents().get(0);
		private final Assignment cRefAAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cRefARefParserRuleCall_7_0 = (RuleCall)cRefAAssignment_7.eContents().get(0);
		private final Keyword cMustKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cNotAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final Keyword cNotNotKeyword_9_0 = (Keyword)cNotAssignment_9.eContents().get(0);
		private final Keyword cHaveOccurredBeforeKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Group cGroup_11 = (Group)cGroup.eContents().get(11);
		private final Keyword cWithinKeyword_11_0 = (Keyword)cGroup_11.eContents().get(0);
		private final Assignment cMinValAssignment_11_1 = (Assignment)cGroup_11.eContents().get(1);
		private final RuleCall cMinValINTTerminalRuleCall_11_1_0 = (RuleCall)cMinValAssignment_11_1.eContents().get(0);
		private final Group cGroup_11_2 = (Group)cGroup_11.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_11_2_0 = (Keyword)cGroup_11_2.eContents().get(0);
		private final Assignment cMaxValAssignment_11_2_1 = (Assignment)cGroup_11_2.eContents().get(1);
		private final RuleCall cMaxValINTTerminalRuleCall_11_2_1_0 = (RuleCall)cMaxValAssignment_11_2_1.eContents().get(0);
		private final Keyword cMsKeyword_11_3 = (Keyword)cGroup_11.eContents().get(3);
		
		//// Whenever B (OR|AND D...) occurs then A (OR|AND C...) should (not) have occurred before
		//Precedence:
		//    '<-' 'whenever' eitherB?= 'either'? refB += Ref+ ('occurs')?
		//    'then' eitherA?= 'either'? refA += Ref+ 'must' not?= 'not'?
		//    'have-occurred-before' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'<-' 'whenever' eitherB?= 'either'? refB += Ref+ ('occurs')?
		//'then' eitherA?= 'either'? refA += Ref+ 'must' not?= 'not'?
		//'have-occurred-before' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup() { return cGroup; }
		
		//'<-'
		public Keyword getLessThanSignHyphenMinusKeyword_0() { return cLessThanSignHyphenMinusKeyword_0; }
		
		//'whenever'
		public Keyword getWheneverKeyword_1() { return cWheneverKeyword_1; }
		
		//eitherB?= 'either'?
		public Assignment getEitherBAssignment_2() { return cEitherBAssignment_2; }
		
		//'either'
		public Keyword getEitherBEitherKeyword_2_0() { return cEitherBEitherKeyword_2_0; }
		
		//refB += Ref+
		public Assignment getRefBAssignment_3() { return cRefBAssignment_3; }
		
		//Ref
		public RuleCall getRefBRefParserRuleCall_3_0() { return cRefBRefParserRuleCall_3_0; }
		
		//('occurs')?
		public Keyword getOccursKeyword_4() { return cOccursKeyword_4; }
		
		//'then'
		public Keyword getThenKeyword_5() { return cThenKeyword_5; }
		
		//eitherA?= 'either'?
		public Assignment getEitherAAssignment_6() { return cEitherAAssignment_6; }
		
		//'either'
		public Keyword getEitherAEitherKeyword_6_0() { return cEitherAEitherKeyword_6_0; }
		
		//refA += Ref+
		public Assignment getRefAAssignment_7() { return cRefAAssignment_7; }
		
		//Ref
		public RuleCall getRefARefParserRuleCall_7_0() { return cRefARefParserRuleCall_7_0; }
		
		//'must'
		public Keyword getMustKeyword_8() { return cMustKeyword_8; }
		
		//not?= 'not'?
		public Assignment getNotAssignment_9() { return cNotAssignment_9; }
		
		//'not'
		public Keyword getNotNotKeyword_9_0() { return cNotNotKeyword_9_0; }
		
		//'have-occurred-before'
		public Keyword getHaveOccurredBeforeKeyword_10() { return cHaveOccurredBeforeKeyword_10; }
		
		//('within' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup_11() { return cGroup_11; }
		
		//'within'
		public Keyword getWithinKeyword_11_0() { return cWithinKeyword_11_0; }
		
		//minVal = INT
		public Assignment getMinValAssignment_11_1() { return cMinValAssignment_11_1; }
		
		//INT
		public RuleCall getMinValINTTerminalRuleCall_11_1_0() { return cMinValINTTerminalRuleCall_11_1_0; }
		
		//('-' maxVal = INT)?
		public Group getGroup_11_2() { return cGroup_11_2; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_11_2_0() { return cHyphenMinusKeyword_11_2_0; }
		
		//maxVal = INT
		public Assignment getMaxValAssignment_11_2_1() { return cMaxValAssignment_11_2_1; }
		
		//INT
		public RuleCall getMaxValINTTerminalRuleCall_11_2_1_0() { return cMaxValINTTerminalRuleCall_11_2_1_0; }
		
		//'ms'
		public Keyword getMsKeyword_11_3() { return cMsKeyword_11_3; }
	}
	public class EndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.End");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRefRefParserRuleCall_0_0 = (RuleCall)cRefAssignment_0.eContents().get(0);
		private final Keyword cOccursLastKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// Existential //
		//End:
		//    ref += Ref+ 'occurs-last'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ref += Ref+ 'occurs-last'
		public Group getGroup() { return cGroup; }
		
		//ref += Ref+
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }
		
		//Ref
		public RuleCall getRefRefParserRuleCall_0_0() { return cRefRefParserRuleCall_0_0; }
		
		//'occurs-last'
		public Keyword getOccursLastKeyword_1() { return cOccursLastKeyword_1; }
	}
	public class InitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Init");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRefRefParserRuleCall_0_0 = (RuleCall)cRefAssignment_0.eContents().get(0);
		private final Keyword cOccursFirstKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Init:
		//    ref += Ref+ 'occurs-first'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ref += Ref+ 'occurs-first'
		public Group getGroup() { return cGroup; }
		
		//ref += Ref+
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }
		
		//Ref
		public RuleCall getRefRefParserRuleCall_0_0() { return cRefRefParserRuleCall_0_0; }
		
		//'occurs-first'
		public Keyword getOccursFirstKeyword_1() { return cOccursFirstKeyword_1; }
	}
	public class AtMostElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.AtMost");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRefRefParserRuleCall_0_0 = (RuleCall)cRefAssignment_0.eContents().get(0);
		private final Keyword cOccursAtMostKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNumAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNumINTTerminalRuleCall_2_0 = (RuleCall)cNumAssignment_2.eContents().get(0);
		private final Keyword cTimesKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//AtMost:
		//     ref += Ref+ 'occurs-at-most' num = INT 'times'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ref += Ref+ 'occurs-at-most' num = INT 'times'
		public Group getGroup() { return cGroup; }
		
		//ref += Ref+
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }
		
		//Ref
		public RuleCall getRefRefParserRuleCall_0_0() { return cRefRefParserRuleCall_0_0; }
		
		//'occurs-at-most'
		public Keyword getOccursAtMostKeyword_1() { return cOccursAtMostKeyword_1; }
		
		//num = INT
		public Assignment getNumAssignment_2() { return cNumAssignment_2; }
		
		//INT
		public RuleCall getNumINTTerminalRuleCall_2_0() { return cNumINTTerminalRuleCall_2_0; }
		
		//'times'
		public Keyword getTimesKeyword_3() { return cTimesKeyword_3; }
	}
	public class ExactElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.Exact");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRefRefParserRuleCall_0_0 = (RuleCall)cRefAssignment_0.eContents().get(0);
		private final Keyword cOccursExactlyKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNumAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNumINTTerminalRuleCall_2_0 = (RuleCall)cNumAssignment_2.eContents().get(0);
		private final Keyword cTimesKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cConsecutivelyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Keyword cConsecutivelyConsecutivelyKeyword_4_0 = (Keyword)cConsecutivelyAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cWithPeriodicityOfKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cMinValAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cMinValINTTerminalRuleCall_5_1_0 = (RuleCall)cMinValAssignment_5_1.eContents().get(0);
		private final Group cGroup_5_2 = (Group)cGroup_5.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_5_2_0 = (Keyword)cGroup_5_2.eContents().get(0);
		private final Assignment cMaxValAssignment_5_2_1 = (Assignment)cGroup_5_2.eContents().get(1);
		private final RuleCall cMaxValINTTerminalRuleCall_5_2_1_0 = (RuleCall)cMaxValAssignment_5_2_1.eContents().get(0);
		private final Keyword cMsKeyword_5_3 = (Keyword)cGroup_5.eContents().get(3);
		
		//Exact:
		//     ref += Ref+ 'occurs-exactly' num = INT 'times' consecutively?= 'consecutively'? ('with-periodicity-of' minVal = INT ('-' maxVal = INT)? 'ms')?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ref += Ref+ 'occurs-exactly' num = INT 'times' consecutively?= 'consecutively'? ('with-periodicity-of' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup() { return cGroup; }
		
		//ref += Ref+
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }
		
		//Ref
		public RuleCall getRefRefParserRuleCall_0_0() { return cRefRefParserRuleCall_0_0; }
		
		//'occurs-exactly'
		public Keyword getOccursExactlyKeyword_1() { return cOccursExactlyKeyword_1; }
		
		//num = INT
		public Assignment getNumAssignment_2() { return cNumAssignment_2; }
		
		//INT
		public RuleCall getNumINTTerminalRuleCall_2_0() { return cNumINTTerminalRuleCall_2_0; }
		
		//'times'
		public Keyword getTimesKeyword_3() { return cTimesKeyword_3; }
		
		//consecutively?= 'consecutively'?
		public Assignment getConsecutivelyAssignment_4() { return cConsecutivelyAssignment_4; }
		
		//'consecutively'
		public Keyword getConsecutivelyConsecutivelyKeyword_4_0() { return cConsecutivelyConsecutivelyKeyword_4_0; }
		
		//('with-periodicity-of' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup_5() { return cGroup_5; }
		
		//'with-periodicity-of'
		public Keyword getWithPeriodicityOfKeyword_5_0() { return cWithPeriodicityOfKeyword_5_0; }
		
		//minVal = INT
		public Assignment getMinValAssignment_5_1() { return cMinValAssignment_5_1; }
		
		//INT
		public RuleCall getMinValINTTerminalRuleCall_5_1_0() { return cMinValINTTerminalRuleCall_5_1_0; }
		
		//('-' maxVal = INT)?
		public Group getGroup_5_2() { return cGroup_5_2; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_5_2_0() { return cHyphenMinusKeyword_5_2_0; }
		
		//maxVal = INT
		public Assignment getMaxValAssignment_5_2_1() { return cMaxValAssignment_5_2_1; }
		
		//INT
		public RuleCall getMaxValINTTerminalRuleCall_5_2_1_0() { return cMaxValINTTerminalRuleCall_5_2_1_0; }
		
		//'ms'
		public Keyword getMsKeyword_5_3() { return cMsKeyword_5_3; }
	}
	public class AtLeastElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.AtLeast");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRefRefParserRuleCall_0_0 = (RuleCall)cRefAssignment_0.eContents().get(0);
		private final Keyword cOccursAtLeastKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNumAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNumINTTerminalRuleCall_2_0 = (RuleCall)cNumAssignment_2.eContents().get(0);
		private final Keyword cTimesKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cWithPeriodicityOfKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cMinValAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cMinValINTTerminalRuleCall_4_1_0 = (RuleCall)cMinValAssignment_4_1.eContents().get(0);
		private final Group cGroup_4_2 = (Group)cGroup_4.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_4_2_0 = (Keyword)cGroup_4_2.eContents().get(0);
		private final Assignment cMaxValAssignment_4_2_1 = (Assignment)cGroup_4_2.eContents().get(1);
		private final RuleCall cMaxValINTTerminalRuleCall_4_2_1_0 = (RuleCall)cMaxValAssignment_4_2_1.eContents().get(0);
		private final Keyword cMsKeyword_4_3 = (Keyword)cGroup_4.eContents().get(3);
		
		//AtLeast:
		//    ref += Ref+ 'occurs-at-least' num = INT 'times' ('with-periodicity-of' minVal = INT ('-' maxVal = INT)? 'ms')?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ref += Ref+ 'occurs-at-least' num = INT 'times' ('with-periodicity-of' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup() { return cGroup; }
		
		//ref += Ref+
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }
		
		//Ref
		public RuleCall getRefRefParserRuleCall_0_0() { return cRefRefParserRuleCall_0_0; }
		
		//'occurs-at-least'
		public Keyword getOccursAtLeastKeyword_1() { return cOccursAtLeastKeyword_1; }
		
		//num = INT
		public Assignment getNumAssignment_2() { return cNumAssignment_2; }
		
		//INT
		public RuleCall getNumINTTerminalRuleCall_2_0() { return cNumINTTerminalRuleCall_2_0; }
		
		//'times'
		public Keyword getTimesKeyword_3() { return cTimesKeyword_3; }
		
		//('with-periodicity-of' minVal = INT ('-' maxVal = INT)? 'ms')?
		public Group getGroup_4() { return cGroup_4; }
		
		//'with-periodicity-of'
		public Keyword getWithPeriodicityOfKeyword_4_0() { return cWithPeriodicityOfKeyword_4_0; }
		
		//minVal = INT
		public Assignment getMinValAssignment_4_1() { return cMinValAssignment_4_1; }
		
		//INT
		public RuleCall getMinValINTTerminalRuleCall_4_1_0() { return cMinValINTTerminalRuleCall_4_1_0; }
		
		//('-' maxVal = INT)?
		public Group getGroup_4_2() { return cGroup_4_2; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_4_2_0() { return cHyphenMinusKeyword_4_2_0; }
		
		//maxVal = INT
		public Assignment getMaxValAssignment_4_2_1() { return cMaxValAssignment_4_2_1; }
		
		//INT
		public RuleCall getMaxValINTTerminalRuleCall_4_2_1_0() { return cMaxValINTTerminalRuleCall_4_2_1_0; }
		
		//'ms'
		public Keyword getMsKeyword_4_3() { return cMsKeyword_4_3; }
	}
	
	public class ActionTypeElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "nl.esi.comma.behavior.scl.Scl.ActionType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cObservableEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cObservableObservableKeyword_0_0 = (Keyword)cObservableEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cTriggerEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cTriggerTriggerKeyword_1_0 = (Keyword)cTriggerEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cPreConditionEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cPreConditionPreConditionKeyword_2_0 = (Keyword)cPreConditionEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cConjunctionEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cConjunctionAndKeyword_3_0 = (Keyword)cConjunctionEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum ActionType:
		//    Observable = 'Observable' | Trigger = 'Trigger' | PreCondition = 'Pre-condition' | Conjunction = 'And'
		//;
		public EnumRule getRule() { return rule; }
		
		//Observable = 'Observable' | Trigger = 'Trigger' | PreCondition = 'Pre-condition' | Conjunction = 'And'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Observable = 'Observable'
		public EnumLiteralDeclaration getObservableEnumLiteralDeclaration_0() { return cObservableEnumLiteralDeclaration_0; }
		
		//'Observable'
		public Keyword getObservableObservableKeyword_0_0() { return cObservableObservableKeyword_0_0; }
		
		//Trigger = 'Trigger'
		public EnumLiteralDeclaration getTriggerEnumLiteralDeclaration_1() { return cTriggerEnumLiteralDeclaration_1; }
		
		//'Trigger'
		public Keyword getTriggerTriggerKeyword_1_0() { return cTriggerTriggerKeyword_1_0; }
		
		//PreCondition = 'Pre-condition'
		public EnumLiteralDeclaration getPreConditionEnumLiteralDeclaration_2() { return cPreConditionEnumLiteralDeclaration_2; }
		
		//'Pre-condition'
		public Keyword getPreConditionPreConditionKeyword_2_0() { return cPreConditionPreConditionKeyword_2_0; }
		
		//Conjunction = 'And'
		public EnumLiteralDeclaration getConjunctionEnumLiteralDeclaration_3() { return cConjunctionEnumLiteralDeclaration_3; }
		
		//'And'
		public Keyword getConjunctionAndKeyword_3_0() { return cConjunctionAndKeyword_3_0; }
	}
	
	private final ModelElements pModel;
	private final CompositionElements pComposition;
	private final SequenceDefElements pSequenceDef;
	private final ParamActElements pParamAct;
	private final RefElements pRef;
	private final RefStepElements pRefStep;
	private final RefSequenceElements pRefSequence;
	private final FeaturesElements pFeatures;
	private final FeatureElements pFeature;
	private final ActionsElements pActions;
	private final ActionParamElements pActionParam;
	private final ActionElements pAction;
	private final ActionTypeElements eActionType;
	private final TemplatesElements pTemplates;
	private final PastElements pPast;
	private final FutureElements pFuture;
	private final DependenciesElements pDependencies;
	private final ChoiceElements pChoice;
	private final ExistentialElements pExistential;
	private final ExclusiveChoiceElements pExclusiveChoice;
	private final SimpleChoiceElements pSimpleChoice;
	private final NotChainSuccessionElements pNotChainSuccession;
	private final NotCoExistanceElements pNotCoExistance;
	private final NotSuccessionElements pNotSuccession;
	private final ChainSuccessionElements pChainSuccession;
	private final AlternateSuccessionElements pAlternateSuccession;
	private final SuccessionElements pSuccession;
	private final CoExistanceElements pCoExistance;
	private final RespondedExistenceElements pRespondedExistence;
	private final ChainPrecedenceElements pChainPrecedence;
	private final ChainResponseElements pChainResponse;
	private final AlternateResponseElements pAlternateResponse;
	private final AlternatePrecedenceElements pAlternatePrecedence;
	private final ResponseElements pResponse;
	private final PrecedenceElements pPrecedence;
	private final EndElements pEnd;
	private final InitElements pInit;
	private final AtMostElements pAtMost;
	private final ExactElements pExact;
	private final AtLeastElements pAtLeast;
	
	private final Grammar grammar;
	
	private final ExpressionsGrammarAccess gaExpressions;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public SclGrammarAccess(GrammarProvider grammarProvider,
			ExpressionsGrammarAccess gaExpressions,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaExpressions = gaExpressions;
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pComposition = new CompositionElements();
		this.pSequenceDef = new SequenceDefElements();
		this.pParamAct = new ParamActElements();
		this.pRef = new RefElements();
		this.pRefStep = new RefStepElements();
		this.pRefSequence = new RefSequenceElements();
		this.pFeatures = new FeaturesElements();
		this.pFeature = new FeatureElements();
		this.pActions = new ActionsElements();
		this.pActionParam = new ActionParamElements();
		this.pAction = new ActionElements();
		this.eActionType = new ActionTypeElements();
		this.pTemplates = new TemplatesElements();
		this.pPast = new PastElements();
		this.pFuture = new FutureElements();
		this.pDependencies = new DependenciesElements();
		this.pChoice = new ChoiceElements();
		this.pExistential = new ExistentialElements();
		this.pExclusiveChoice = new ExclusiveChoiceElements();
		this.pSimpleChoice = new SimpleChoiceElements();
		this.pNotChainSuccession = new NotChainSuccessionElements();
		this.pNotCoExistance = new NotCoExistanceElements();
		this.pNotSuccession = new NotSuccessionElements();
		this.pChainSuccession = new ChainSuccessionElements();
		this.pAlternateSuccession = new AlternateSuccessionElements();
		this.pSuccession = new SuccessionElements();
		this.pCoExistance = new CoExistanceElements();
		this.pRespondedExistence = new RespondedExistenceElements();
		this.pChainPrecedence = new ChainPrecedenceElements();
		this.pChainResponse = new ChainResponseElements();
		this.pAlternateResponse = new AlternateResponseElements();
		this.pAlternatePrecedence = new AlternatePrecedenceElements();
		this.pResponse = new ResponseElements();
		this.pPrecedence = new PrecedenceElements();
		this.pEnd = new EndElements();
		this.pInit = new InitElements();
		this.pAtMost = new AtMostElements();
		this.pExact = new ExactElements();
		this.pAtLeast = new AtLeastElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("nl.esi.comma.behavior.scl.Scl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public ExpressionsGrammarAccess getExpressionsGrammarAccess() {
		return gaExpressions;
	}
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//    features += Features*
	//    actions += Actions+
	//    sequences += SequenceDef*
	//    'Requirements'
	//    composition += Composition*
	//    ('for-configurations' commonFeatures += [Feature|ID]+)?
	//    templates += Templates*
	//    useLabels?= 'use-provided-labels'?
	//;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//Composition:
	//    'constraint' name = ID 'is-composed-of' '{' templates += [Templates|ID]+ '}'
	//    ('description' descTxt = STRING)?
	//    ('for-configurations' commonFeatures += [Feature|ID]+ ';')?
	//    ('requirement-tags' tagStr += STRING* ';')?
	//;
	public CompositionElements getCompositionAccess() {
		return pComposition;
	}
	
	public ParserRule getCompositionRule() {
		return getCompositionAccess().getRule();
	}
	
	//SequenceDef:
	//    'Sequence-Def' name = ID '{'
	//        actList += ParamAct+
	//    '}'
	//;
	public SequenceDefElements getSequenceDefAccess() {
		return pSequenceDef;
	}
	
	public ParserRule getSequenceDefRule() {
		return getSequenceDefAccess().getRule();
	}
	
	//ParamAct:
	//    act = [Action|ID] ('['idx = INT']')?
	//;
	public ParamActElements getParamActAccess() {
		return pParamAct;
	}
	
	public ParserRule getParamActRule() {
		return getParamActAccess().getRule();
	}
	
	//Ref returns Ref:
	//    RefSequence | RefStep
	//;
	public RefElements getRefAccess() {
		return pRef;
	}
	
	public ParserRule getRefRule() {
		return getRefAccess().getRule();
	}
	
	//RefStep:
	//    'act' step = [Action|ID] ('['idx = INT']')?
	//;
	public RefStepElements getRefStepAccess() {
		return pRefStep;
	}
	
	public ParserRule getRefStepRule() {
		return getRefStepAccess().getRule();
	}
	
	//RefSequence:
	//    'seq' seq = [SequenceDef|ID]
	//;
	public RefSequenceElements getRefSequenceAccess() {
		return pRefSequence;
	}
	
	public ParserRule getRefSequenceRule() {
		return getRefSequenceAccess().getRule();
	}
	
	//Features:
	//    'feature-list:' '{'
	//        feature += Feature+
	//    '}'
	//;
	public FeaturesElements getFeaturesAccess() {
		return pFeatures;
	}
	
	public ParserRule getFeaturesRule() {
		return getFeaturesAccess().getRule();
	}
	
	//Feature:
	//    name = ID
	//;
	public FeatureElements getFeatureAccess() {
		return pFeature;
	}
	
	public ParserRule getFeatureRule() {
		return getFeatureAccess().getRule();
	}
	
	//Actions:
	//    'action-list:' '{'
	//        act += Action+
	//    '}'
	//;
	public ActionsElements getActionsAccess() {
		return pActions;
	}
	
	public ParserRule getActionsRule() {
		return getActionsAccess().getRule();
	}
	
	//ActionParam:
	//    'with' '(' parameters+=Expression (',' parameters+=Expression)* ')'
	//;
	public ActionParamElements getActionParamAccess() {
		return pActionParam;
	}
	
	public ParserRule getActionParamRule() {
		return getActionParamAccess().getRule();
	}
	
	//// name is used as reference|ID by templates. In generator this must be changed
	//Action:
	//    act = ActionType name = ID label = STRING (actParam += ActionParam+)?
	//;
	public ActionElements getActionAccess() {
		return pAction;
	}
	
	public ParserRule getActionRule() {
		return getActionAccess().getRule();
	}
	
	//enum ActionType:
	//    Observable = 'Observable' | Trigger = 'Trigger' | PreCondition = 'Pre-condition' | Conjunction = 'And'
	//;
	public ActionTypeElements getActionTypeAccess() {
		return eActionType;
	}
	
	public EnumRule getActionTypeRule() {
		return getActionTypeAccess().getRule();
	}
	
	///*
	//    templates can be divided into two main groups: existence templates
	//    and relation templates. The former is a set of unary templates. They can be
	//    expressed as predicates over one variable. The latter comprises rules that are
	//    imposed on target activities, when activation tasks occur. Relation templates
	//    thus correspond to binary predicates over two variables.
	// */
	//Templates:
	//    // name = ID type += (Existential | Relation | Coupling | Negative | Choice)+ ('for-configurations' features += [Feature|ID]+)?
	//    name = ID type += ( Dependencies | Past | Future | Choice | Existential)+ ('for-configurations' features += [Feature|ID]+)?
	//;
	public TemplatesElements getTemplatesAccess() {
		return pTemplates;
	}
	
	public ParserRule getTemplatesRule() {
		return getTemplatesAccess().getRule();
	}
	
	//Past:
	//    'P'
	//    type += (Precedence | AlternatePrecedence | ChainPrecedence)+
	//;
	public PastElements getPastAccess() {
		return pPast;
	}
	
	public ParserRule getPastRule() {
		return getPastAccess().getRule();
	}
	
	//Future:
	//    'F'
	//    type += (Response | AlternateResponse | ChainResponse)+
	//;
	public FutureElements getFutureAccess() {
		return pFuture;
	}
	
	public ParserRule getFutureRule() {
		return getFutureAccess().getRule();
	}
	
	//Dependencies:
	//    'PF'
	//    type += (Succession  | CoExistance |AlternateSuccession  | ChainSuccession
	//            | RespondedExistence | NotSuccession | NotCoExistance | NotChainSuccession )+
	//;
	public DependenciesElements getDependenciesAccess() {
		return pDependencies;
	}
	
	public ParserRule getDependenciesRule() {
		return getDependenciesAccess().getRule();
	}
	
	//Choice:
	//    'C'
	//    type += (SimpleChoice | ExclusiveChoice) +
	//;
	public ChoiceElements getChoiceAccess() {
		return pChoice;
	}
	
	public ParserRule getChoiceRule() {
		return getChoiceAccess().getRule();
	}
	
	//Existential:
	//    'E'
	//    type += (AtLeast | AtMost | Init | End | Exact)+
	//;
	public ExistentialElements getExistentialAccess() {
		return pExistential;
	}
	
	public ParserRule getExistentialRule() {
		return getExistentialAccess().getRule();
	}
	
	//// Choice
	//ExclusiveChoice:
	//    eitherA?= 'either'? refA += Ref+ 'or' eitherB?= 'either'? refB += Ref+ 'eventually-occur-but-not-together'
	//;
	public ExclusiveChoiceElements getExclusiveChoiceAccess() {
		return pExclusiveChoice;
	}
	
	public ParserRule getExclusiveChoiceRule() {
		return getExclusiveChoiceAccess().getRule();
	}
	
	//SimpleChoice:
	//    refA += Ref+ 'eventually-occur'
	//;
	public SimpleChoiceElements getSimpleChoiceAccess() {
		return pSimpleChoice;
	}
	
	public ParserRule getSimpleChoiceRule() {
		return getSimpleChoiceAccess().getRule();
	}
	
	//// NEGATION //
	//// A (or | and C..) occurs if and only if not followed immediately by B (or | and D..)
	//NotChainSuccession:
	//    '!<>' eitherA?= 'either'? refA += Ref+ ('occurs')? 'if-and-only-if-not-followed-immediately-by' eitherB?= 'either'? refB += Ref+
	//;
	public NotChainSuccessionElements getNotChainSuccessionAccess() {
		return pNotChainSuccession;
	}
	
	public ParserRule getNotChainSuccessionRule() {
		return getNotChainSuccessionAccess().getRule();
	}
	
	////A and B (and C..) do not occur together (implies exclusive choice)
	//NotCoExistance:
	//    '!-'refA += Ref+ 'do-not-occur-together'
	//;
	public NotCoExistanceElements getNotCoExistanceAccess() {
		return pNotCoExistance;
	}
	
	public ParserRule getNotCoExistanceRule() {
		return getNotCoExistanceAccess().getRule();
	}
	
	//// A (or | and C..) occurs if and only if not followed by B (or | and C..)
	//NotSuccession:
	//    '!<-->' eitherA?= 'either'? refA += Ref+ ('occurs')?
	//    'if-and-only-if-not-followed-by' eitherB?= 'either'? refB += Ref+
	//;
	public NotSuccessionElements getNotSuccessionAccess() {
		return pNotSuccession;
	}
	
	public ParserRule getNotSuccessionRule() {
		return getNotSuccessionAccess().getRule();
	}
	
	///// TOGETHER ////
	//// A (or | and C..) occurs if and only if followed immediately by B (or | and D..)
	//ChainSuccession:
	//    '<>' eitherA?= 'either'? refA += Ref+ 'occurs-if-and-only-if-immediately-followed-by'
	//          eitherB?= 'either'? refB += Ref+ ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
	//;
	public ChainSuccessionElements getChainSuccessionAccess() {
		return pChainSuccession;
	}
	
	public ParserRule getChainSuccessionRule() {
		return getChainSuccessionAccess().getRule();
	}
	
	//// A occurs if and only if followed by B with no A and B (C, D) in between
	//AlternateSuccession:
	//    '<!>' eitherA?= 'either'? refA += Ref+ ('occurs')? 'if-and-only-if-followed-by'
	//          eitherB?= 'either'? refB += Ref+ 'with'
	//          eitherC?= 'either'? negation?= 'no'? refC += Ref+ 'in-between'
	//;
	public AlternateSuccessionElements getAlternateSuccessionAccess() {
		return pAlternateSuccession;
	}
	
	public ParserRule getAlternateSuccessionRule() {
		return getAlternateSuccessionAccess().getRule();
	}
	
	//// A (or | and C..) occurs if and only if followed by B (or | and D..)
	//Succession:
	//    '<-->' eitherA?= 'either'? refA += Ref+ ('occurs')? 'if-and-only-if-followed-by'
	//           eitherB?= 'either'? refB += Ref+ ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
	//;
	public SuccessionElements getSuccessionAccess() {
		return pSuccession;
	}
	
	public ParserRule getSuccessionRule() {
		return getSuccessionAccess().getRule();
	}
	
	//// A and B (and C..) occur together
	//CoExistance:
	//    '-' refA += Ref+ 'occur-together'
	//;
	public CoExistanceElements getCoExistanceAccess() {
		return pCoExistance;
	}
	
	public ParserRule getCoExistanceRule() {
		return getCoExistanceAccess().getRule();
	}
	
	//RespondedExistence:
	//    '-|-' 'if' eitherA?= 'either'? refA += Ref+ ('occurs')? 'then' eitherB?= 'either'? refB += Ref+ 'occurs-as-well'
	//;
	public RespondedExistenceElements getRespondedExistenceAccess() {
		return pRespondedExistence;
	}
	
	public ParserRule getRespondedExistenceRule() {
		return getRespondedExistenceAccess().getRule();
	}
	
	//////// RELATION ////////
	//// Whenever B (OR|AND D...) occurs then A (OR|AND C..) must (not) immediately precede it
	//ChainPrecedence:
	//    '<' 'whenever' eitherB?= 'either'? refB += Ref+ ('occurs')?
	//    'then' eitherA?= 'either'? refA += Ref+ 'must' not?= 'not'?
	//    'have-occurred-immediately-before' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
	//;
	public ChainPrecedenceElements getChainPrecedenceAccess() {
		return pChainPrecedence;
	}
	
	public ParserRule getChainPrecedenceRule() {
		return getChainPrecedenceAccess().getRule();
	}
	
	//// If A (OR|AND C..) occurs then B (OR|AND D...) (does not) immediately follow
	//ChainResponse:
	//    '>' 'if' eitherA?= 'either'? refA += Ref+ ('occurs')?
	//    'then' eitherB?= 'either'? refB += Ref+ 'must' not?= 'not'?
	//    'immediately-follow' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
	//;
	public ChainResponseElements getChainResponseAccess() {
		return pChainResponse;
	}
	
	public ParserRule getChainResponseRule() {
		return getChainResponseAccess().getRule();
	}
	
	//// If A (OR|AND X...) occurs then B (OR|AND Y...) must follow with no (only) A (OR|AND X...) and C (OR|AND Z...) in between
	//AlternateResponse:
	//    '!>' 'if' eitherA?= 'either'? refA += Ref+ ('occurs')?
	//    'then' eitherB?= 'either'? refB += Ref+ 'must-follow' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
	//    'with' not?= 'no'? eitherC?= 'either'? refC += Ref+ 'in-between'
	//;
	public AlternateResponseElements getAlternateResponseAccess() {
		return pAlternateResponse;
	}
	
	public ParserRule getAlternateResponseRule() {
		return getAlternateResponseAccess().getRule();
	}
	
	//// Whenever B (OR|AND Y...) occurs then A (OR|AND X...) must have occurred before with no B (OR|AND Y...) and C (OR|AND Z...) in between
	//AlternatePrecedence:
	//    '<!' 'whenever' eitherB?= 'either'? refB += Ref ('occurs')?
	//    'then' eitherA?= 'either'? refA += Ref 'must-have-occurred' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
	//    'with' not?= 'no'? eitherC?= 'either'? refC += Ref 'in-between'
	//;
	public AlternatePrecedenceElements getAlternatePrecedenceAccess() {
		return pAlternatePrecedence;
	}
	
	public ParserRule getAlternatePrecedenceRule() {
		return getAlternatePrecedenceAccess().getRule();
	}
	
	//Response:
	//    '->' 'if' eitherA?= 'either'? refA += Ref+ ('occurs')?
	//    'then' eitherB?= 'either'? refB += Ref+ 'must' not?= 'not'?
	//    'eventually-follow' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
	//;
	public ResponseElements getResponseAccess() {
		return pResponse;
	}
	
	public ParserRule getResponseRule() {
		return getResponseAccess().getRule();
	}
	
	//// Whenever B (OR|AND D...) occurs then A (OR|AND C...) should (not) have occurred before
	//Precedence:
	//    '<-' 'whenever' eitherB?= 'either'? refB += Ref+ ('occurs')?
	//    'then' eitherA?= 'either'? refA += Ref+ 'must' not?= 'not'?
	//    'have-occurred-before' ('within' minVal = INT ('-' maxVal = INT)? 'ms')?
	//;
	public PrecedenceElements getPrecedenceAccess() {
		return pPrecedence;
	}
	
	public ParserRule getPrecedenceRule() {
		return getPrecedenceAccess().getRule();
	}
	
	//// Existential //
	//End:
	//    ref += Ref+ 'occurs-last'
	//;
	public EndElements getEndAccess() {
		return pEnd;
	}
	
	public ParserRule getEndRule() {
		return getEndAccess().getRule();
	}
	
	//Init:
	//    ref += Ref+ 'occurs-first'
	//;
	public InitElements getInitAccess() {
		return pInit;
	}
	
	public ParserRule getInitRule() {
		return getInitAccess().getRule();
	}
	
	//AtMost:
	//     ref += Ref+ 'occurs-at-most' num = INT 'times'
	//;
	public AtMostElements getAtMostAccess() {
		return pAtMost;
	}
	
	public ParserRule getAtMostRule() {
		return getAtMostAccess().getRule();
	}
	
	//Exact:
	//     ref += Ref+ 'occurs-exactly' num = INT 'times' consecutively?= 'consecutively'? ('with-periodicity-of' minVal = INT ('-' maxVal = INT)? 'ms')?
	//;
	public ExactElements getExactAccess() {
		return pExact;
	}
	
	public ParserRule getExactRule() {
		return getExactAccess().getRule();
	}
	
	//AtLeast:
	//    ref += Ref+ 'occurs-at-least' num = INT 'times' ('with-periodicity-of' minVal = INT ('-' maxVal = INT)? 'ms')?
	//;
	public AtLeastElements getAtLeastAccess() {
		return pAtLeast;
	}
	
	public ParserRule getAtLeastRule() {
		return getAtLeastAccess().getRule();
	}
	
	////import "http://www.esi.nl/comma/types/Types" as types
	////import "http://www.esi.nl/comma/signature/InterfaceSignature" as signature
	//Variable: name= ID ;
	public ExpressionsGrammarAccess.VariableElements getVariableAccess() {
		return gaExpressions.getVariableAccess();
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//Expression: ExpressionLevel1;
	public ExpressionsGrammarAccess.ExpressionElements getExpressionAccess() {
		return gaExpressions.getExpressionAccess();
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//ExpressionLevel1 returns Expression:        // Left associativity
	//    ExpressionLevel2
	//    ( ({ExpressionAnd.left=current}            ("AND" | "and")    right=ExpressionLevel2)
	//    | ({ExpressionOr.left=current}            ("OR" | "or")    right=ExpressionLevel2)
	//    )*
	//;
	public ExpressionsGrammarAccess.ExpressionLevel1Elements getExpressionLevel1Access() {
		return gaExpressions.getExpressionLevel1Access();
	}
	
	public ParserRule getExpressionLevel1Rule() {
		return getExpressionLevel1Access().getRule();
	}
	
	//ExpressionLevel2 returns Expression:        // Left associativity
	//    ExpressionLevel3
	//    ( ({ExpressionEqual.left=current}        "=="    right=ExpressionLevel3)
	//    | ({ExpressionNEqual.left=current}        "!="    right=ExpressionLevel3)
	//    )*
	//;
	public ExpressionsGrammarAccess.ExpressionLevel2Elements getExpressionLevel2Access() {
		return gaExpressions.getExpressionLevel2Access();
	}
	
	public ParserRule getExpressionLevel2Rule() {
		return getExpressionLevel2Access().getRule();
	}
	
	//ExpressionLevel3 returns Expression:        // Left associativity
	//    ExpressionLevel4
	//    ( ({ExpressionGeq.left    =current}        ">="    right=ExpressionLevel4)
	//    | ({ExpressionGreater.left=current}        ">"        right=ExpressionLevel4)
	//    | ({ExpressionLeq.left    =current}        "<="    right=ExpressionLevel4)
	//    | ({ExpressionLess.left   =current}        "<"        right=ExpressionLevel4)
	//    )*
	//;
	public ExpressionsGrammarAccess.ExpressionLevel3Elements getExpressionLevel3Access() {
		return gaExpressions.getExpressionLevel3Access();
	}
	
	public ParserRule getExpressionLevel3Rule() {
		return getExpressionLevel3Access().getRule();
	}
	
	//ExpressionLevel4 returns Expression:        // Left associativity
	//    ExpressionLevel5
	//    ( ({ExpressionAddition.left   =current}    "+"        right=ExpressionLevel5)
	//    | ({ExpressionSubtraction.left=current}    "-"        right=ExpressionLevel5)
	//    )*
	//;
	public ExpressionsGrammarAccess.ExpressionLevel4Elements getExpressionLevel4Access() {
		return gaExpressions.getExpressionLevel4Access();
	}
	
	public ParserRule getExpressionLevel4Rule() {
		return getExpressionLevel4Access().getRule();
	}
	
	//ExpressionLevel5 returns Expression:        // Left associativity
	//    ExpressionLevel6
	//    ( ({ExpressionMultiply.left=current}    "*"        right=ExpressionLevel6)
	//    | ({ExpressionDivision.left=current}    "/"        right=ExpressionLevel6)
	//    | ({ExpressionMaximum.left =current}    "max"    right=ExpressionLevel6)
	//    | ({ExpressionMinimum.left =current}    "min"    right=ExpressionLevel6)
	//    | ({ExpressionModulo.left  =current}    "mod"    right=ExpressionLevel6)
	//    )*
	//;
	public ExpressionsGrammarAccess.ExpressionLevel5Elements getExpressionLevel5Access() {
		return gaExpressions.getExpressionLevel5Access();
	}
	
	public ParserRule getExpressionLevel5Rule() {
		return getExpressionLevel5Access().getRule();
	}
	
	//ExpressionLevel6 returns Expression:        // Right associativity
	//    ExpressionLevel7
	//    ( ({ExpressionPower.left=current}        "^"     right=ExpressionLevel6)
	//    )?
	//;
	public ExpressionsGrammarAccess.ExpressionLevel6Elements getExpressionLevel6Access() {
		return gaExpressions.getExpressionLevel6Access();
	}
	
	public ParserRule getExpressionLevel6Rule() {
		return getExpressionLevel6Access().getRule();
	}
	
	//ExpressionLevel7 returns Expression:
	//    ExpressionNot | ExpressionMinus | ExpressionPlus | ExpressionLevel8
	//;
	public ExpressionsGrammarAccess.ExpressionLevel7Elements getExpressionLevel7Access() {
		return gaExpressions.getExpressionLevel7Access();
	}
	
	public ParserRule getExpressionLevel7Rule() {
		return getExpressionLevel7Access().getRule();
	}
	
	//ExpressionNot:
	//    ("NOT" | "not") sub=ExpressionLevel8
	//;
	public ExpressionsGrammarAccess.ExpressionNotElements getExpressionNotAccess() {
		return gaExpressions.getExpressionNotAccess();
	}
	
	public ParserRule getExpressionNotRule() {
		return getExpressionNotAccess().getRule();
	}
	
	//ExpressionMinus:
	//    "-" sub=ExpressionLevel8
	//;
	public ExpressionsGrammarAccess.ExpressionMinusElements getExpressionMinusAccess() {
		return gaExpressions.getExpressionMinusAccess();
	}
	
	public ParserRule getExpressionMinusRule() {
		return getExpressionMinusAccess().getRule();
	}
	
	//ExpressionPlus:
	//    "+" sub=ExpressionLevel8
	//;
	public ExpressionsGrammarAccess.ExpressionPlusElements getExpressionPlusAccess() {
		return gaExpressions.getExpressionPlusAccess();
	}
	
	public ParserRule getExpressionPlusRule() {
		return getExpressionPlusAccess().getRule();
	}
	
	///*ExpressionLevel8 returns Expression:
	//    ExpressionLevel9 (({ExpressionRecordAccess.record = current} '.' field = [types::RecordField | ID]) |
	//                      ({ExpressionMapRW.map = current} '[' key = Expression ('->' value = Expression)? ']'))*
	//;*/
	////ExpressionLevel9 returns Expression:
	//ExpressionLevel8 returns Expression:
	//    ExpressionBracket |
	//    ExpressionConstantBool |
	//    ExpressionConstantInt |
	//    //ExpressionConstantReal |
	//    ExpressionConstantString |
	//    //ExpressionEnumLiteral |
	//    ExpressionVariable |
	//    //ExpressionRecord |
	//    //ExpressionAny |
	//    //ExpressionBulkData |
	//    //ExpressionFunctionCall |
	//    ExpressionQuantifier |
	//    ExpressionTypeAnnotated
	//;
	public ExpressionsGrammarAccess.ExpressionLevel8Elements getExpressionLevel8Access() {
		return gaExpressions.getExpressionLevel8Access();
	}
	
	public ParserRule getExpressionLevel8Rule() {
		return getExpressionLevel8Access().getRule();
	}
	
	//ExpressionBracket:
	//    "(" sub=Expression ")"
	//;
	public ExpressionsGrammarAccess.ExpressionBracketElements getExpressionBracketAccess() {
		return gaExpressions.getExpressionBracketAccess();
	}
	
	public ParserRule getExpressionBracketRule() {
		return getExpressionBracketAccess().getRule();
	}
	
	//ExpressionConstantBool:
	//    value=BOOL_LITERAL
	//;
	public ExpressionsGrammarAccess.ExpressionConstantBoolElements getExpressionConstantBoolAccess() {
		return gaExpressions.getExpressionConstantBoolAccess();
	}
	
	public ParserRule getExpressionConstantBoolRule() {
		return getExpressionConstantBoolAccess().getRule();
	}
	
	//ExpressionConstantInt:
	//    value=INT
	//;
	public ExpressionsGrammarAccess.ExpressionConstantIntElements getExpressionConstantIntAccess() {
		return gaExpressions.getExpressionConstantIntAccess();
	}
	
	public ParserRule getExpressionConstantIntRule() {
		return getExpressionConstantIntAccess().getRule();
	}
	
	///*ExpressionConstantReal:
	//    value=ID
	//;*/
	//ExpressionConstantString:
	//    value = STRING
	//;
	public ExpressionsGrammarAccess.ExpressionConstantStringElements getExpressionConstantStringAccess() {
		return gaExpressions.getExpressionConstantStringAccess();
	}
	
	public ParserRule getExpressionConstantStringRule() {
		return getExpressionConstantStringAccess().getRule();
	}
	
	//ExpressionEnumLiteral:
	//    //(interface = [signature::Signature|ID] '::')? type = [types::EnumTypeDecl] "::" literal = [types::EnumElement]
	//    type = ID "::" literal = ID
	//;
	public ExpressionsGrammarAccess.ExpressionEnumLiteralElements getExpressionEnumLiteralAccess() {
		return gaExpressions.getExpressionEnumLiteralAccess();
	}
	
	public ParserRule getExpressionEnumLiteralRule() {
		return getExpressionEnumLiteralAccess().getRule();
	}
	
	//ExpressionVariable:
	//    //variable=[Variable | ID]
	//    name= ID
	//;
	public ExpressionsGrammarAccess.ExpressionVariableElements getExpressionVariableAccess() {
		return gaExpressions.getExpressionVariableAccess();
	}
	
	public ParserRule getExpressionVariableRule() {
		return getExpressionVariableAccess().getRule();
	}
	
	///*ExpressionRecord:
	//    (interface = [signature::Signature|ID] '::')? type = [types::RecordTypeDecl] '{' fields+=Field (',' fields+=Field)* '}'
	//;
	//Field:
	//    recordField = [types::RecordField | ID] '=' exp = Expression
	//;
	//ExpressionBulkData : {ExpressionBulkData}
	//    'Bulkdata' '<' (size = Int)? '>'
	//;*/
	//ExpressionAny :
	//    {ExpressionAny} "*"
	//;
	public ExpressionsGrammarAccess.ExpressionAnyElements getExpressionAnyAccess() {
		return gaExpressions.getExpressionAnyAccess();
	}
	
	public ParserRule getExpressionAnyRule() {
		return getExpressionAnyAccess().getRule();
	}
	
	//// We assume a library of functions. They can be provided in a separate model.
	//// At the moment we have just a check of the function name and then a dedicated check for the types of the arguments
	//// TODO: consider an expression (or function) Expression in Interval
	//ExpressionFunctionCall:
	//    functionName = ID '(' (args += Expression (',' args += Expression)*)? ')'
	//;
	public ExpressionsGrammarAccess.ExpressionFunctionCallElements getExpressionFunctionCallAccess() {
		return gaExpressions.getExpressionFunctionCallAccess();
	}
	
	public ParserRule getExpressionFunctionCallRule() {
		return getExpressionFunctionCallAccess().getRule();
	}
	
	////TODO rename to iterator? after adding 'delete' the expression is not a pure quantifier any more
	//ExpressionQuantifier:
	//    quantifier = QUANTIFIER '(' iterator = Variable 'in' collection = Expression ':' condition = Expression ')'
	//;
	public ExpressionsGrammarAccess.ExpressionQuantifierElements getExpressionQuantifierAccess() {
		return gaExpressions.getExpressionQuantifierAccess();
	}
	
	public ParserRule getExpressionQuantifierRule() {
		return getExpressionQuantifierAccess().getRule();
	}
	
	//ExpressionTypeAnnotated returns Expression:
	//    TypeAnnotation( ({ExpressionVector.typeAnnotation = current} '[' (elements += Expression (',' elements += Expression)*)? ']') |
	//                    ({ExpressionMap.typeAnnotation = current} '{' (pairs += Pair (',' pairs += Pair)*)? '}'))
	//;
	public ExpressionsGrammarAccess.ExpressionTypeAnnotatedElements getExpressionTypeAnnotatedAccess() {
		return gaExpressions.getExpressionTypeAnnotatedAccess();
	}
	
	public ParserRule getExpressionTypeAnnotatedRule() {
		return getExpressionTypeAnnotatedAccess().getRule();
	}
	
	//TypeAnnotation :
	//    '<'type = ID '>'
	//;
	public ExpressionsGrammarAccess.TypeAnnotationElements getTypeAnnotationAccess() {
		return gaExpressions.getTypeAnnotationAccess();
	}
	
	public ParserRule getTypeAnnotationRule() {
		return getTypeAnnotationAccess().getRule();
	}
	
	//Pair:
	//    key = Expression '->' value = Expression
	//;
	public ExpressionsGrammarAccess.PairElements getPairAccess() {
		return gaExpressions.getPairAccess();
	}
	
	public ParserRule getPairRule() {
		return getPairAccess().getRule();
	}
	
	//enum QUANTIFIER :
	//    EXISTS = 'exists' |
	//    FORALL = 'forAll' |
	//    DELETE = 'delete'
	//;
	public ExpressionsGrammarAccess.QUANTIFIERElements getQUANTIFIERAccess() {
		return gaExpressions.getQUANTIFIERAccess();
	}
	
	public EnumRule getQUANTIFIERRule() {
		return getQUANTIFIERAccess().getRule();
	}
	
	//// --- add extra superclasses in metamodel -------
	//ExpressionBinary returns Expression:
	//    {ExpressionBinary}
	//;
	public ExpressionsGrammarAccess.ExpressionBinaryElements getExpressionBinaryAccess() {
		return gaExpressions.getExpressionBinaryAccess();
	}
	
	public ParserRule getExpressionBinaryRule() {
		return getExpressionBinaryAccess().getRule();
	}
	
	//ConcreteExpressionBinary returns ExpressionBinary:
	//      {ExpressionAnd}
	//    | {ExpressionOr}
	//    | {ExpressionEqual}
	//    | {ExpressionNEqual}
	//    | {ExpressionGeq}
	//    | {ExpressionGreater}
	//    | {ExpressionLeq}
	//    | {ExpressionLess}
	//    | {ExpressionAddition}
	//    | {ExpressionSubtraction}
	//    | {ExpressionMultiply}
	//    | {ExpressionDivision}
	//    | {ExpressionMaximum}
	//    | {ExpressionMinimum}
	//    | {ExpressionModulo}
	//    | {ExpressionPower}
	//;
	public ExpressionsGrammarAccess.ConcreteExpressionBinaryElements getConcreteExpressionBinaryAccess() {
		return gaExpressions.getConcreteExpressionBinaryAccess();
	}
	
	public ParserRule getConcreteExpressionBinaryRule() {
		return getConcreteExpressionBinaryAccess().getRule();
	}
	
	//ExpressionUnary returns Expression:
	//    {ExpressionUnary}
	//;
	public ExpressionsGrammarAccess.ExpressionUnaryElements getExpressionUnaryAccess() {
		return gaExpressions.getExpressionUnaryAccess();
	}
	
	public ParserRule getExpressionUnaryRule() {
		return getExpressionUnaryAccess().getRule();
	}
	
	//ConcreteExpressionUnary returns ExpressionUnary:
	//      {ExpressionNot}
	//    | {ExpressionMinus}
	//    | {ExpressionPlus}
	//    | {ExpressionBracket}
	//;
	public ExpressionsGrammarAccess.ConcreteExpressionUnaryElements getConcreteExpressionUnaryAccess() {
		return gaExpressions.getConcreteExpressionUnaryAccess();
	}
	
	public ParserRule getConcreteExpressionUnaryRule() {
		return getConcreteExpressionUnaryAccess().getRule();
	}
	
	////Extensions to the Types language
	///*
	//@Override
	//TypeReference: InterfaceAwareType type = [types::TypeDecl] ;
	//@Override
	//VectorTypeConstructor:
	//    InterfaceAwareType type = [types::TypeDecl] (dimensions += Dimension)+
	//;
	//@Override
	//MapTypeConstructor:
	//    'map' '<' InterfaceAwareType type = [types::TypeDecl] ',' valueType = Type '>'
	//;
	//fragment InterfaceAwareType:
	//    (interface = [signature::Signature|ID] '::')?
	//;
	//*/
	//// === Terminals =======
	//terminal BOOL_LITERAL returns ecore::EBoolean:
	//    'true' | 'false' | 'TRUE' | 'FALSE' | 'True' | 'False'
	//;
	public TerminalRule getBOOL_LITERALRule() {
		return gaExpressions.getBOOL_LITERALRule();
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
